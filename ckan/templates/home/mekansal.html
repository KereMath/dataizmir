{% extends "page.html" %}

{% block subtitle %}{{ _('Mekansal G√∂sterim') }}{% endblock %}

{%- block header %}
  {% include "header.html" %}
   <div id="title" class="package-title container-fluid" style="background-image:url(&quot;/base/images/theme/background_photo.jpg&quot;);color: #fff;">
      <div class="background-overlay">
      <div class="restricted-max-width">
      <div class="col-xs-12 col-md-10 col-md-offset-1">
      <div id="title-container" class="col-xs-10 col-md-6 text-left">
      <h1 style="margin-left: 200px;">Mekansal G√∂sterim</h1>
      </div>
      <div id="stats" class="col-xs-12 col-md-4 col-md-offset-2">
      <div class="col-xs-12" style="text-align: center;margin-top: 20px;font-size: 16px;">
      </div>
      </div>
      </div>
      </div>
      </div>
      </div>
{%- endblock %}

{% block primary %}
<style>
  .search-form { display:none !important; }
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body {
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
    background-color: #f8f9fa; color: #333;
  }

  .page-container { display: flex; height: 100vh; overflow: hidden; }
  .sidebar-filter {
    width: 360px; flex: 0 0 360px;
    background: #fff; border-right: 1px solid #e9ecef; z-index: 1;
  }
  .layers-panel { position: sticky; top: 0; width: 100%; height: 100vh; background: #fff; overflow: hidden; }

  .panel-header {
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    color: white; padding: 20px; border-bottom: 1px solid rgba(255,255,255,0.1);
  }
  .stats-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; }
  .stat-item { background: rgba(255,255,255,0.15); padding: 10px; border-radius: 8px; text-align: center; backdrop-filter: blur(10px); }
  .stat-number { font-size: 1.4rem; font-weight: 700; display: block; }
  .stat-label { font-size: 0.75rem; opacity: 0.9; margin-top: 3px; }

  .search-section { padding: 12px 16px; border-bottom: 1px solid #e9ecef; display:flex; align-items:center; gap:10px }
  .search-input { width: 100%; padding: 10px 12px; border: 1px solid #ced4da; border-radius: 8px; font-size: 14px; background-color: #fff; }
  .search-input:focus { outline: none; border-color: #007bff; box-shadow: 0 0 0 0.2rem rgba(0,123,255,.15); }

  .layers-content { height: calc(100vh - 20px - 15px - 20px - 48px - 1px); overflow-y: auto; padding-bottom: 20px; }

  .package-group {
    margin: 12px 16px; border: 1px solid #e9ecef; border-radius: 12px; overflow: hidden; background: white; box-shadow: 0 2px 4px rgba(0,0,0,0.05);
  }
  .package-header {
    background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
    padding: 12px 14px; cursor: pointer; user-select: none; border-bottom: 1px solid rgba(0,0,0,0.04);
  }
  .package-title-row { display: flex; justify-content: space-between; align-items: center; margin-bottom: 6px; }
  .package-title { font-size: 15px; font-weight: 600; color: #2c3e50; margin: 0; line-height: 1.3; }
  .collapse-indicator { background: none; border: none; font-size: 18px; color: #6c757d; cursor: pointer; padding: 4px; }
  .collapse-indicator.collapsed { transform: rotate(-90deg); }
  .package-meta { display: flex; align-items: center; gap: 10px; }
  .resource-count { background: #28a745; color: white; padding: 3px 8px; border-radius: 12px; font-size: 11px; font-weight: 600; }

  .resources-container { display: block; max-height: 400px; overflow-y: auto; }
  .resources-container.collapsed { display: none; }

  .resource-item { display: flex; align-items: center; justify-content: space-between; padding: 10px 12px; border-bottom: 1px solid #f1f3f4; cursor: pointer; }
  .resource-item:last-child { border-bottom: none; }
  .resource-item.active { background: linear-gradient(135deg, #e3f2fd 0%, #f0f8ff 100%); border-left: 4px solid #1976d2; }

  .resource-info { flex: 1; min-width: 0; }
  .resource-name { font-size: 13px; font-weight: 500; color: #495057; margin: 0 0 5px 0; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
  .resource-meta { display: flex; align-items: center; gap: 8px; }
  .format-badge { display: inline-block; padding: 2px 6px; border-radius: 4px; font-size: 9px; font-weight: 600; text-transform: uppercase; }
  .format-geojson { background: #d1ecf1; color: #0c5460; }
  .format-shp     { background: #dcfce7; color: #166534; }
  .format-kml     { background: #ddd6fe; color: #5b21b6; }
  .format-csv     { background: #d4edda; color: #155724; }
  .format-json    { background: #fff3cd; color: #856404; }
  .format-api     { background: #f0f9ff; color: #0c4a6e; }
  .format-xlsx    { background: #e2e3e5; color: #383d41; }
  .format-other   { background: #f1f5f9; color: #475569; }
  .format-wms     { background: #d6eaff; color: #2a61a0; }
  .format-geotiff { background: #fdf6e3; color: #b58900; }

  .modern-toggle { position: relative; display: inline-block; width: 44px; height: 24px; margin-left: 10px; }
  .modern-toggle input { opacity: 0; width: 0; height: 0; }
  .toggle-slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background: linear-gradient(135deg, #ddd, #ccc); transition: all .3s ease; border-radius: 24px; box-shadow: inset 0 2px 4px rgba(0,0,0,0.1); }
  .toggle-slider:before { position: absolute; content: ""; height: 18px; width: 18px; left: 3px; bottom: 3px; background: white; transition: all .3s ease; border-radius: 50%; box-shadow: 0 2px 6px rgba(0,0,0,0.2); }
  input:checked + .toggle-slider { background: linear-gradient(135deg, #28a745, #20c997); }
  .wms-resource input:checked + .toggle-slider { background: linear-gradient(135deg, #2a61a0, #4c82c2); }
  .geotiff-resource input:checked + .toggle-slider { background: linear-gradient(135deg, #b58900, #cb9700); }
  input:checked + .toggle-slider:before { transform: translateX(20px); }

  .bulk-actions { padding: 10px 12px; background: rgba(248, 249, 250, 0.8); border-top: 1px solid #dee2e6; display: flex; gap: 8px; }
  .bulk-btn { flex: 1; padding: 6px 12px; border: 1px solid #dee2e6; border-radius: 6px; font-size: 11px; font-weight: 600; background: white; color: #495057; cursor: pointer; }
  .bulk-btn:hover { background: #007bff; color: white; border-color: #007bff; }

  .main-container { flex: 1; position: relative; }
  #map { position: absolute; inset: 0; width: 100%; height: 100%; z-index: 0; }

  .loading-section, .error-section { text-align: center; padding: 40px 20px; color: #6c757d; }
  .error-section { background: #f8d7da; color: #721c24; margin: 20px; border-radius: 8px; }

  .popup-content { max-width: 280px; font-size: 12px; line-height: 1.4; }
  .popup-resource-header { background: linear-gradient(135deg, #007bff, #0056b3); color: white; padding: 8px 12px; margin: -8px -12px 8px -12px; border-radius: 4px 4px 0 0; font-weight: 600; }
  .leaflet-overlay-pane .feature-glow { filter: drop-shadow(0 0 4px rgba(0,123,255,.9)) drop-shadow(0 0 10px rgba(0,123,255,.6)); }
  .leaflet-marker-pane .pin-glow { box-shadow: 0 0 0 2px #fff inset, 0 0 8px rgba(0,123,255,.9), 0 0 14px rgba(0,123,255,.5); border-radius: 50%; transition: transform .2s ease; }
  .pin-focus { transform: scale(1.35); }
  .dimmed-vector { opacity: .25 !important; }
  .dimmed-marker { opacity: .35 !important; }

  /* === Mini "Se√ßili Katmanlar" paneli (harita √ºst√ºnde sol √ºst) === */
  .selected-layers-panel {
    position: sticky; top: 12px; left: 12px;
    display: flex; flex-direction: column; gap: 8px;
    z-index: 1000; pointer-events: auto; padding: 12px; max-height: calc(100vh - 24px); overflow: auto;
  }
  .selected-layers-right {
    flex: 0 0 260px;
    max-width: 260px;
    border-left: 1px solid #e9ecef;
    background: #fff;
  }
  .sel-chip {
    pointer-events: auto;
    display: grid; grid-template-columns: 16px 1fr auto auto; align-items: center; gap: 8px;
    background: rgba(255,255,255,0.98);
    border: 1px solid #e5e7eb; border-radius: 12px; padding: 6px 8px;
    box-shadow: 0 6px 18px rgba(0,0,0,.08); max-width: 320px;
    backdrop-filter: saturate(1.1) blur(4px);
  }
  .sel-dot { width: 12px; height: 12px; border-radius: 50%; border: 2px solid #fff; box-shadow: 0 0 0 1px rgba(0,0,0,.1); }
  .sel-name { min-width: 0; font-size: 12px; font-weight: 600; color: #223; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
  .sel-actions { display: flex; gap: 6px; }
  .sel-btn {
    border: 1px solid #e5e7eb; background: #fff; border-radius: 8px; padding: 4px 6px;
    cursor: pointer; font-size: 11px; line-height: 1; color: #374151;
  }
  .sel-btn:hover { background: #f3f4f6; }
  .sel-btn.danger:hover { background: #fee2e2; border-color: #fecaca; }
  .sel-btn.active { border-color:#60a5fa; background:#e0f2fe; }
</style>

<div class="page-container">
  <!-- SOL: Sabit katman paneli -->
  <div class="sidebar-filter">
    <div class="layers-panel" id="layersPanel">
      <div class="panel-header">
        <div class="stats-grid">
          <div class="stat-item"><span class="stat-number" id="totalSpatialResources">-</span><div class="stat-label">Kaynak</div></div>
          <div class="stat-item"><span class="stat-number" id="totalSpatialPackages">-</span><div class="stat-label">Paket</div></div>
          <div class="stat-item"><span class="stat-number" id="activeLayers">-</span><div class="stat-label">Aktif Katman</div></div>
          <div class="stat-item"><span class="stat-number" id="totalFormats">-</span><div class="stat-label">Format</div></div>
        </div>
      </div>

      <div class="search-section">
        <input type="search" class="search-input" id="layerSearch" placeholder="Mekan ara...">
      </div>

      <div class="layers-content" id="spatialLayersContainer">
        <div class="loading-section">Mekansal katmanlar y√ºkleniyor...</div>
      </div>
    </div>
  </div>

  <!-- SAƒû: Harita + Se√ßili Katmanlar Paneli -->
  <div class="main-container">
    <div id="map"></div>

    <!-- mini se√ßili katmanlar paneli -->
     <div class="selected-layers-right">
 <div class="selected-layers-panel" id="selectedLayersPanel"></div>
     </div>
   
  </div>
</div>

<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

<link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.css"/>
<link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.Default.css"/>
<script src="https://unpkg.com/leaflet.markercluster@1.5.3/dist/leaflet.markercluster.js"></script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet-omnivore/0.3.4/leaflet-omnivore.min.js"></script>
<script src="https://unpkg.com/shpjs@3.6.0/dist/shp.min.js"></script>

<script src="https://unpkg.com/georaster@1.5.6/dist/georaster.browser.bundle.min.js"></script>
<script src="https://unpkg.com/georaster-layer-for-leaflet@3.10.0/dist/georaster-layer-for-leaflet.min.js"></script>
<script src="https://unpkg.com/geotiff@2.0.7/dist/geotiff.bundle.min.js"></script>

<script>
  console.log('Modern Mekansal G√∂r√ºnt√ºleme Sistemi + Se√ßili Katmanlar paneli - D√úZELTƒ∞LMƒ∞≈û');

  class SpatialMapManager {
    constructor() {
      this.map = null;
      this.spatialData = [];
      this.packageGroups = {};
      this.resourceLayers = {};
      this.activeResources = new Set();

      this.defaultBaseMap = null;
      this.collapsedPackages = new Set();
      this.layerPanes = {};
      this.panesCreated = false;

      // focus durumu
      this.focusMode = false;
      this.focusedResourceId = null;

      this.init();
    }

    async init() {
      try {
        this.initMap();
        this.createGlobalPanes();
        await this.loadSpatialData();
        this.setupEventListeners();
        this.renderLayers();
        this.updateStats();
        this.renderSelectedLayersPanel();
      } catch (error) {
        console.error('Initialization hatasƒ±:', error);
        this.showError('Mekansal veriler y√ºklenirken hata olu≈ütu: ' + error.message);
      }
    }

    initMap() {
      this.map = L.map('map').setView([38.4237, 27.1428], 10);
      this.defaultBaseMap = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        maxZoom: 19, attribution: '¬© OpenStreetMap contributors'
      }).addTo(this.map);
    }

    // Global pane yapƒ±sƒ± - Z-index sorunlarƒ±nƒ± √ß√∂zer
    createGlobalPanes() {
      if (!this.panesCreated) {
        // Raster katmanlar i√ßin (WMS, GeoTIFF)
        const rasterPane = this.map.createPane('rasterPane');
        rasterPane.style.zIndex = 450;
        
        // Vector katmanlar i√ßin (Poligon, √áizgi)
        const vectorPane = this.map.createPane('vectorPane');
        vectorPane.style.zIndex = 750;
        
        // Marker katmanlar i√ßin (Noktalar)
        const markerPane = this.map.createPane('markerPane');
        markerPane.style.zIndex = 850;
        
        this.panesCreated = true;
      }
    }

    async loadSpatialData() {
      const response = await fetch('/api/spatial-resources/list', { credentials: 'include' });
      const data = await response.json();
      if (!data.success) throw new Error(data.error || 'Spatial resources API hatasƒ±');
      this.spatialData = data.spatial_resources || [];
      this.createPackageGroups();
    }

    createPackageGroups() {
      this.packageGroups = {};
      this.spatialData.forEach(resource => {
        const pid = resource.package_id;
        if (!this.packageGroups[pid]) {
          this.packageGroups[pid] = { id: pid, name: resource.package_title, package_name: resource.package_name, resources: [] };
        }
        this.packageGroups[pid].resources.push(resource);
        this.resourceLayers[resource.resource_id] = {
          resource, layer: L.layerGroup(), visible: false, loaded: false, _cluster: null, _vector: null
        };
      });
    }

    // D√ºzeltilmi≈ü pane se√ßimi
    getPaneForResource(format, isRaster = false) {
      const fmt = (format || '').toLowerCase();
      if (['wms', 'wfs', 'geotiff'].includes(fmt) || isRaster) {
        return 'rasterPane';
      }
      return 'vectorPane'; // Genel olarak vector katmanlar i√ßin
    }

    async addLayerFromUrl(url, format, layerGroup, resourceId) {
      layerGroup.clearLayers();
      let newLayer;
      const resource = this.resourceLayers[resourceId].resource;

      try {
        switch ((format || '').toLowerCase()) {
          case 'wms': {
            const layerName = resource.wms_layer || 'layer';
            const paneName = this.getPaneForResource(format, true);
            newLayer = L.tileLayer.wms(url, { 
              layers: layerName, 
              format: 'image/png', 
              transparent: true, 
              attribution: `WMS: ${resource.resource_name}`, 
              pane: paneName 
            });
            break;
          }
          case 'wfs': {
            const layerName = resource.wfs_layer || 'layer';
            const paneName = this.getPaneForResource(format, true);
            newLayer = L.tileLayer.wms(url, { 
              layers: layerName, 
              format: 'image/png', 
              transparent: true, 
              attribution: `WFS: ${resource.resource_name}`, 
              pane: paneName 
            });
            break;
          }
          case 'geotiff':
            await this.processGeoTiffData(url, resourceId);
            return;
          default:
            throw new Error('Desteklenmeyen URL tabanlƒ± format: ' + format);
        }
        if (newLayer) { 
          layerGroup.addLayer(newLayer); 
        }
      } catch (error) {
        console.error(`[DEBUG] Katman ekleme hatasƒ± (${format}):`, error);
        this.showResourceError(resourceId, `${(format || '').toUpperCase()} dosyasƒ± i≈ülenemedi: ${error.message}`);
        const checkbox = document.querySelector(`input[data-resource="${resourceId}"]`);
        if (checkbox) checkbox.checked = false;
      }
    }

    async processGeoTiffData(url, resourceId) {
      try {
        const rl = this.resourceLayers[resourceId];
        const response = await fetch(url);
        if (!response.ok) throw new Error(`HTTP Error: ${response.status}`);
        const arrayBuffer = await response.arrayBuffer();
        const georaster = await window.GeoRaster.parseGeoRaster(arrayBuffer);

        const paneName = this.getPaneForResource('geotiff', true);
        const georasterLayer = new window.GeoRasterLayer({
          georaster, 
          opacity: 0.7, 
          resolution: 256,
          pixelValuesToColorFn: values => {
            const v = values[0]; 
            if (v === georaster.noDataValue) return null;
            const n = (v - georaster.mins[0]) / (georaster.maxs[0] - georaster.mins[0]);
            const r = Math.round(255 * (1 - n)), g = Math.round(255 * n);
            return `rgba(${r}, ${g}, 0, 0.8)`;
          },
          pane: paneName
        });

        rl.layer.clearLayers();
        rl.layer.addLayer(georasterLayer);

        if (georaster.xmin && georaster.xmax && georaster.ymin && georaster.ymax) {
          const b = [[georaster.ymin, georaster.xmin], [georaster.ymax, georaster.xmax]];
          this.map.fitBounds(b);
        }
      } catch (error) {
        console.error('GeoTIFF i≈üleme hatasƒ±:', error);
        this.showResourceError(resourceId, `GeoTIFF dosyasƒ± i≈ülenemedi: ${error.message}`);
        const checkbox = document.querySelector(`input[data-resource="${resourceId}"]`);
        if (checkbox) checkbox.checked = false;
      }
    }

    async processShpData(shpUrl, resourceId) {
      try {
        const response = await fetch(shpUrl);
        if (!response.ok) throw new Error(`HTTP Error: ${response.status}`);
        const buffer = await response.arrayBuffer();
        const geojson = shp.parseZip(buffer);
        if (!geojson || !geojson.features || geojson.features.length === 0) throw new Error('SHP dosyasƒ±nda veri yok.');
        const rl = this.resourceLayers[resourceId];
        this.addGeoJSONToLayer(geojson, rl.layer, resourceId);
      } catch (error) {
        console.error(`SHP i≈üleme hatasƒ±: ${error}`);
        this.showResourceError(resourceId, `SHP dosyasƒ± i≈ülenemedi: ${error.message}`);
        const checkbox = document.querySelector(`input[data-resource="${resourceId}"]`);
        if (checkbox) checkbox.checked = false;
      }
    }

    showResourceError(resourceId, errorMessage) {
      const el = document.getElementById(`resource-${resourceId}`);
      if (el) {
        const info = el.querySelector('.resource-info');
        if (info) {
          info.querySelector('.resource-error')?.remove();
          const div = document.createElement('div');
          div.className = 'resource-error';
          div.style.cssText = 'color:#dc3545;font-size:10px;margin-top:3px;font-style:italic;';
          div.textContent = errorMessage.length > 60 ? errorMessage.substring(0,60) + '...' : errorMessage;
          div.title = errorMessage;
          info.appendChild(div);
        }
        const cb = el.querySelector('input[type="checkbox"]');
        if (cb) cb.checked = false;
      }
    }

    // Ana d√ºzeltme burada - katman ekleme sƒ±rasƒ± ve pane kullanƒ±mƒ±
    addGeoJSONToLayer(geojsonData, layerGroup, resourceId) {
      try {
        layerGroup.clearLayers();
        const resource = this.spatialData.find(r => r.resource_id === resourceId);
        if (!resource) return;

        const color = this.getResourceColor(resourceId);
        const isFocused = (id) => this.focusMode && this.focusedResourceId === id;
        const focused = isFocused(resourceId);

        // Vector katmanlar i√ßin pane
        const vectorPaneName = this.getPaneForResource(resource.format, false);
        
        // Marker'lar i√ßin pane
        const markerPaneName = 'markerPane';

        // 1. Vector katmanƒ± (Poligon ve √ßizgiler)
        const vectorLayer = L.geoJSON(geojsonData, {
          pane: vectorPaneName,
          filter: (feature) => feature.geometry && feature.geometry.type !== 'Point',
          style: () => {
            return {
              color,
              weight: focused ? 4 : 2.5,
              opacity: focused ? 0.95 : 0.7,
              fillColor: color,
              fillOpacity: focused ? 0.3 : 0.15,
              className: focused ? 'feature-glow' : ''
            };
          },
          onEachFeature: (feature, layer) => {
            const popupContent = this.createPopupContent(feature, resource);
            layer.bindPopup(popupContent, { maxWidth: 300, className: 'custom-popup' });
          }
        });

        // 2. Marker cluster (Noktalar)
        const cluster = L.markerClusterGroup({
          spiderfyOnEveryZoom: false,
          spiderfyOnMaxZoom: true,
          showCoverageOnHover: false,
          disableClusteringAtZoom: 16,
          maxClusterRadius: 50
        });

        const getDivIcon = (isFocused) => L.divIcon({
          className: isFocused ? 'pin-glow pin-focus' : 'pin-glow',
          html: `<div style="width:${isFocused?18:14}px;height:${isFocused?18:14}px;background:${color};border:2px solid #fff;border-radius:50%"></div>`,
          iconSize: [isFocused?22:18, isFocused?22:18],
          iconAnchor: [isFocused?11:9, isFocused?11:9]
        });

        const pointLayer = L.geoJSON(geojsonData, {
          filter: (feature) => feature.geometry && feature.geometry.type === 'Point',
          pointToLayer: (feature, latlng) => {
            return L.marker(latlng, { icon: getDivIcon(focused), pane: markerPaneName });
          },
          onEachFeature: (feature, layer) => {
            const popupContent = this.createPopupContent(feature, resource);
            layer.bindPopup(popupContent, { maxWidth: 300, className: 'custom-popup' });
          }
        });
        
        cluster.addLayer(pointLayer);

        // √ñNEMLI: √ñnce cluster, sonra vector - bu sƒ±ra katmanlarƒ±n doƒüru g√∂sterilmesini saƒülar
        layerGroup.addLayer(cluster);
        layerGroup.addLayer(vectorLayer);

        // Referanslarƒ± sakla
        const rl = this.resourceLayers[resourceId];
        rl._cluster = cluster;
        rl._vector = vectorLayer;

        // Katmanlarƒ± doƒüru sƒ±rayla √∂ne getir
        setTimeout(() => {
          if (vectorLayer.bringToFront) vectorLayer.bringToFront();
          if (cluster.bringToFront) cluster.bringToFront();
        }, 100);

      } catch (error) {
        console.error('[DEBUG] GeoJSON ekleme hatasƒ±:', error);
        this.showResourceError(resourceId, `GeoJSON i≈ülenemedi: ${error.message}`);
      }
    }

    createPopupContent(feature, resource) {
      let content = '<div class="popup-content">';
      content += `<div class="popup-resource-header">${resource.resource_name}<br><small style="opacity:.8;">${resource.format || 'Bilinmiyor'}</small></div>`;
      if (feature.properties && typeof feature.properties === 'object') {
        Object.entries(feature.properties).forEach(([k, v]) => {
          if (v !== null && v !== undefined && v !== '') content += `<div><strong>${k}:</strong> ${v}</div>`;
        });
      }
      content += `<div style="margin-top: 12px; padding-top: 10px; border-top: 1px solid #eee; text-align: center;">
        <a href="/dataset/${resource.package_name}/resource/${resource.resource_id}" target="_blank" style="color:#007bff;text-decoration:none;font-weight:500;">Kaynaƒüƒ± G√∂r√ºnt√ºle ‚Üí</a>
      </div>`;
      content += '</div>';
      return content;
    }

    showLoadingForResource(resourceId) {
      const el = document.getElementById(`resource-${resourceId}`);
      el?.querySelector('.toggle-slider')?.style && (el.querySelector('.toggle-slider').style.background = 'linear-gradient(135deg, #ffc107, #e0a800)');
    }
    
    hideLoadingForResource(resourceId) {
      const el = document.getElementById(`resource-${resourceId}`);
      const cb = el?.querySelector('input[type="checkbox"]');
      const slider = el?.querySelector('.toggle-slider');
      if (slider && cb) slider.style.background = cb.checked ? 'linear-gradient(135deg, #28a745, #20c997)' : 'linear-gradient(135deg, #ddd, #ccc)';
    }

    async loadResourceData(resourceId) {
      const rl = this.resourceLayers[resourceId];
      if (!rl || rl.loaded) return;

      try {
        this.showLoadingForResource(resourceId);

        const fmt = (rl.resource.format || '').toLowerCase();
        if (['wms','wfs','geotiff'].includes(fmt)) {
          await this.addLayerFromUrl(rl.resource.url, fmt, rl.layer, resourceId);
          rl.loaded = true; 
          this.hideLoadingForResource(resourceId); 
          return;
        }

        const apiUrl = `/api/spatial-resources/${resourceId}/data`;
        const response = await fetch(apiUrl, { credentials: 'include' });
        if (!response.ok) throw response;
        const result = await response.json();

        if (!result.success) throw new Error(result.error || 'Bilinmeyen API hatasƒ±');
        if (result.type === 'shp') await this.processShpData(result.url, resourceId);
        else if (result.type === 'api') await this.processApiDataFrontend(result.url, resourceId);
        else if (result.type === 'geojson_url') await this.processGeoJsonFrontend(result.url, resourceId);
        else { 
          this.addGeoJSONToLayer(result.data, rl.layer, resourceId); 
          rl.loaded = true; 
        }

        this.hideLoadingForResource(resourceId);
      } catch (error) {
        console.error('[DEBUG] Resource data y√ºklenirken hata:', error);
        this.hideLoadingForResource(resourceId);
        this.showResourceError(resourceId, error.message || 'Hata');
        const cb = document.querySelector(`input[data-resource="${resourceId}"]`); 
        if (cb) cb.checked = false;
      }
    }

    async processApiDataFrontend(apiUrl, resourceId) {
      const rl = this.resourceLayers[resourceId];
      try {
        const res = await fetch(apiUrl, { mode: 'cors' });
        if (!res.ok) throw new Error(`API isteƒüi ba≈üarƒ±sƒ±z: Status ${res.status}`);
        const json = await res.json();
        const dataArray = this.findDataArrayInJson(json);
        if (!dataArray || dataArray.length === 0) throw new Error('API yanƒ±tƒ±nda uygun formatta (liste) veri bulunamadƒ±.');
        rl.fetchedData = dataArray;

        const coord = this.smartDetectCoordinateColumnsJS(dataArray);
        if (coord.found) {
          const geojson = this.convertDataToGeoJSON(dataArray, coord.columns);
          this.addGeoJSONToLayer(geojson, rl.layer, resourceId); 
          rl.loaded = true;
        } else {
          this.hideLoadingForResource(resourceId);
          await this.showManualColumnSelection(resourceId, coord.columns);
        }
      } catch (error) {
        console.error(`[DEBUG] Frontend API i≈üleme hatasƒ±:`, error);
        this.showResourceError(resourceId, error.message || 'API verisi i≈ülenemedi');
        rl.loaded = false;
        const cb = document.querySelector(`input[data-resource="${resourceId}"]`); 
        if (cb) cb.checked = false;
        this.hideLoadingForResource(resourceId);
      }
    }

    findDataArrayInJson(jsonData) {
      if (Array.isArray(jsonData)) return jsonData;
      if (typeof jsonData === 'object' && jsonData !== null) {
        const keys = ['data','results','items','onemliyer','records','features'];
        for (const k of keys) if (k in jsonData && Array.isArray(jsonData[k])) return jsonData[k];
        for (const k in jsonData) if (Array.isArray(jsonData[k]) && jsonData[k].length > 0) return jsonData[k];
      }
      return null;
    }

    smartDetectCoordinateColumnsJS(dataArray) {
      if (!dataArray || dataArray.length === 0) return { found: false, columns: [] };
      const columns = Object.keys(dataArray[0]);

      const latPatterns = [/^(lat|latitude|enlem|y|kuzey)$/i, /lat/i, /enlem/i, /kuzey/i];
      const lonPatterns = [/^(lon|lng|longitude|boylam|x|dogu)$/i, /lon|lng/i, /boylam/i, /dogu/i];
      let latCol = null, lonCol = null;
      for (const p of latPatterns) { if (latCol = columns.find(c => p.test(c))) break; }
      for (const p of lonPatterns) { if (lonCol = columns.find(c => p.test(c))) break; }
      if (latCol && lonCol && latCol !== lonCol) return { found: true, columns: { lat: latCol, lon: lonCol } };
      return { found: false, columns };
    }

    convertDataToGeoJSON(dataArray, coordColumns) {
      const features = [];
      const { lat: latCol, lon: lonCol } = coordColumns;
      for (const row of dataArray) {
        try {
          const lat = parseFloat(String(row[latCol]).replace(',', '.'));
          const lon = parseFloat(String(row[lonCol]).replace(',', '.'));
          if (isNaN(lat) || isNaN(lon) || lat < -90 || lat > 90 || lon < -180 || lon > 180) continue;
          const properties = { ...row };
          features.push({ type: 'Feature', geometry: { type: 'Point', coordinates: [lon, lat] }, properties });
        } catch (_) {}
      }
      return { type: 'FeatureCollection', features };
    }

    async processGeoJsonFrontend(url, resourceId) {
      const rl = this.resourceLayers[resourceId];
      try {
        const response = await fetch(url, { mode: 'cors', credentials: 'include' });
        if (!response.ok) throw new Error(`Dosya y√ºklenemedi: ${response.status} ${response.statusText}`);
        const geojsonData = await response.json();
        if (geojsonData.type !== 'FeatureCollection' && geojsonData.type !== 'Feature') throw new Error('Ge√ßerli bir GeoJSON dosyasƒ± deƒüil.');
        this.addGeoJSONToLayer(geojsonData, rl.layer, resourceId); 
        rl.loaded = true;
      } catch (error) {
        console.error(`[DEBUG] Frontend GeoJSON i≈üleme hatasƒ±:`, error);
        this.showResourceError(resourceId, error.message || 'GeoJSON y√ºklenemedi');
        rl.loaded = false;
        const cb = document.querySelector(`input[data-resource="${resourceId}"]`); 
        if (cb) cb.checked = false;
      }
    }

    async processManualSelection(resourceId, buttonElement) {
      const modal = buttonElement.closest('.column-modal-overlay');
      const latCol = modal.querySelector('#latColumn').value;
      const lonCol = modal.querySelector('#lonColumn').value;
      if (!latCol || !lonCol) { alert('L√ºtfen enlem ve boylam s√ºtunlarƒ±nƒ± se√ßin'); return; }

      const rl = this.resourceLayers[resourceId];
      if (rl && rl.fetchedData) {
        try {
          const geojson = this.convertDataToGeoJSON(rl.fetchedData, { lat: latCol, lon: lonCol });
          this.addGeoJSONToLayer(geojson, rl.layer, resourceId);
          rl.loaded = true;
          this.hideLoadingForResource(resourceId);
          modal.remove();
        } catch(error) { alert('Veri i≈ülenirken hata: ' + error.message); }
        return;
      }

      try {
        const response = await fetch(`/api/spatial-resources/${resourceId}/process-manual`, {
          method: 'POST', 
          headers: { 'Content-Type': 'application/json' }, 
          credentials: 'include',
          body: JSON.stringify({ lat_column: latCol, lon_column: lonCol })
        });
        const result = await response.json();
        if (result.success) {
          this.addGeoJSONToLayer(result.data, rl.layer, resourceId);
          rl.loaded = true; 
          modal.remove();
        } else { 
          alert('Veri i≈ülenirken hata: ' + result.error); 
        }
      } catch (error) { 
        alert('ƒ∞stek g√∂nderilirken hata: ' + error.message); 
      }
    }

    getResourceColor(resourceId) {
      const colors = ['#FF6B6B','#4ECDC4','#45B7D1','#96CEB4','#FECA57','#FF9FF3','#54A0FF','#5F27CD','#00D2D3','#10AC84','#EE5A24','#FF6348'];
      const hash = resourceId.split('').reduce((a, b) => { a = ((a << 5) - a) + b.charCodeAt(0); return a & a; }, 0);
      return colors[Math.abs(hash) % colors.length];
    }

    // Ana toggle fonksiyonu - d√ºzeltilmi≈ü katman g√∂r√ºn√ºrl√ºk y√∂netimi
    async toggleResource(resourceId, isVisible) {
      const rl = this.resourceLayers[resourceId];
      if (!rl) return;

      if (isVisible) {
        if (!rl.loaded) { 
          await this.loadResourceData(resourceId); 
        }
        if (rl.loaded) {
          rl.layer.addTo(this.map);
          this.activeResources.add(resourceId);
          rl.visible = true;

          // Katmanlarƒ± doƒüru sƒ±rada √∂ne getir
          setTimeout(() => {
            const fmt = (rl.resource.format || '').toLowerCase();
            if (['wms', 'geotiff'].includes(fmt)) {
              // Raster katmanlar arkada kalsƒ±n
              rl.layer.eachLayer(l => l.bringToBack?.());
            } else {
              // Vector katmanlar √∂ne gelsin
              if (rl._vector) rl._vector.bringToFront?.();
              if (rl._cluster) rl._cluster.bringToFront?.();
            }
          }, 150);
        }
      } else {
        this.map.removeLayer(rl.layer);
        this.activeResources.delete(resourceId);
        rl.visible = false;

        // Odaƒüƒ± kapat: kapanan katman focus ise
        if (this.focusedResourceId === resourceId) { 
          this.focusMode = false; 
          this.focusedResourceId = null; 
        }
      }

      const item = document.getElementById(`resource-${resourceId}`);
      if (item) item.classList.toggle('active', isVisible);

      this.updateStats();
      this.fitMapToActiveLayers();
      this.updateEmphasis();
      this.renderSelectedLayersPanel();
    }

    /* === ODAK / VURGU === */
    setFocus(resourceId) {
      if (!this.activeResources.has(resourceId)) return;
      this.focusMode = true;
      this.focusedResourceId = resourceId;
      this.updateEmphasis();
      this.renderSelectedLayersPanel();
    }

    clearFocus() {
      this.focusMode = false;
      this.focusedResourceId = null;
      this.updateEmphasis();
      this.renderSelectedLayersPanel();
    }

    // D√ºzeltilmi≈ü emphasis fonksiyonu
    applyEmphasis(resourceId, emphasized) {
      const rl = this.resourceLayers[resourceId];
      if (!rl || !rl.visible) return;

      // Vector katmanlar i√ßin
      if (rl._vector) {
        try {
          rl._vector.eachLayer(l => {
            if (l.setStyle) {
              const color = this.getResourceColor(resourceId);
              l.setStyle({
                color: color,
                opacity: emphasized ? 0.95 : 0.3,
                fillOpacity: emphasized ? 0.3 : 0.1,
                weight: emphasized ? 4 : 2
              });
              
              const el = l.getElement?.();
              if (el) {
                el.classList.toggle('dimmed-vector', !emphasized);
                el.classList.toggle('feature-glow', emphasized);
              }
            }
          });
          
          if (emphasized) {
            setTimeout(() => rl._vector.bringToFront?.(), 10);
          }
        } catch(e) {
          console.warn('Vector emphasis hatasƒ±:', e);
        }
      }

      // Marker cluster i√ßin
      if (rl._cluster) {
        try {
          rl._cluster.eachLayer(m => {
            if (m.setOpacity) m.setOpacity(emphasized ? 1.0 : 0.4);
            
            const icon = m.getElement?.();
            if (icon) {
              icon.classList.toggle('dimmed-marker', !emphasized);
              icon.classList.toggle('pin-focus', emphasized);
            }
          });
          
          if (emphasized) {
            setTimeout(() => rl._cluster.bringToFront?.(), 10);
          }
        } catch(e) {
          console.warn('Cluster emphasis hatasƒ±:', e);
        }
      }

      // Raster katmanlar i√ßin
      rl.layer?.eachLayer(l => { 
        if (l.setOpacity) l.setOpacity(emphasized ? 1.0 : 0.4); 
      });
    }

    // D√ºzeltilmi≈ü updateEmphasis - sadece aktif katmanlarƒ± i≈üle
    updateEmphasis() {
      // √ñnce t√ºm katmanlarƒ± normal duruma getir
      Object.keys(this.resourceLayers).forEach(id => {
        const rl = this.resourceLayers[id];
        if (rl && rl.visible) {
          let emphasized = true;
          
          if (this.focusMode && this.focusedResourceId) {
            // Focus modundaysa sadece focus olan emphasized
            emphasized = (id === this.focusedResourceId);
          }
          // Focus modu yoksa t√ºm aktif katmanlar emphasized
          
          this.applyEmphasis(id, emphasized);
        }
      });
    }

    fitMapToActiveLayers() {
      if (this.activeResources.size === 0) return;
      const allBounds = [];
      
      this.activeResources.forEach(resourceId => {
        const rl = this.resourceLayers[resourceId];
        if (rl && rl.visible && rl.layer.getLayers().length > 0) {
          rl.layer.eachLayer(layer => {
            if (layer.getBounds) {
              allBounds.push(layer.getBounds());
            } else if (layer.getLatLng) {
              const ll = layer.getLatLng();
              allBounds.push(L.latLngBounds([ll, ll]));
            }
          });
        }
      });
      
      if (allBounds.length > 0) {
        const group = new L.featureGroup();
        allBounds.forEach(b => group.addLayer(L.rectangle(b, {opacity:0})));
        if (group.getLayers().length > 0) {
          this.map.fitBounds(group.getBounds(), { padding: [20, 20] });
        }
      }
    }

    /* === Mini Panel: se√ßili katman chip'leri === */
    renderSelectedLayersPanel() {
      const panel = document.getElementById('selectedLayersPanel');
      const ids = [...this.activeResources];

      if (ids.length === 0) {
        panel.innerHTML = ''; 
        return;
      }

      const chips = ids.map(id => {
        const res = this.resourceLayers[id].resource;
        const color = this.getResourceColor(id);
        const focused = (this.focusMode && this.focusedResourceId === id);
        return `
          <div class="sel-chip" data-res="${id}">
            <div class="sel-dot" style="background:${color}"></div>
            <div class="sel-name" title="${res.resource_name}">${res.resource_name}</div>
            <div class="sel-actions">
              <button class="sel-btn ${focused?'active':''}" onclick="spatialMapManager.onChipFocus('${id}')" title="Odaƒüƒ± bu katmana al">üéØ</button>
              <button class="sel-btn" onclick="spatialMapManager.onChipToggle('${id}')" title="Gizle/G√∂ster">üëÅÔ∏è</button>
              <button class="sel-btn danger" onclick="spatialMapManager.onChipClose('${id}')" title="Kapat">‚úï</button>
            </div>
          </div>`;
      }).join('');

      // Odak temizle butonu
      const clearBtn = (this.focusMode && this.focusedResourceId)
        ? `<div class="sel-chip" style="grid-template-columns:auto;gap:6px;justify-items:center;">
             <button class="sel-btn" onclick="spatialMapManager.clearFocus()" title="Odaƒüƒ± temizle">Odaƒüƒ± Temizle</button>
           </div>`
        : '';

      panel.innerHTML = clearBtn + chips;
    }

    onChipFocus(resourceId) {
      // Aynƒ± chip'e tekrar basƒ±lƒ±rsa odaƒüƒ± kaldƒ±r
      if (this.focusMode && this.focusedResourceId === resourceId) {
        this.clearFocus();
      } else {
        this.setFocus(resourceId);
      }
    }

    onChipToggle(resourceId) {
      // G√∂r√ºn√ºrse gizle; gizliyse g√∂ster
      const visible = this.activeResources.has(resourceId);
      this.toggleResource(resourceId, !visible);
    }

    onChipClose(resourceId) {
      // Tamamen devreden √ßƒ±kar
      this.toggleResource(resourceId, false);
    }

    /* Panel i√ßi arama / paket collapse / render */
    togglePackageCollapse(packageId) {
      if (this.collapsedPackages.has(packageId)) this.collapsedPackages.delete(packageId);
      else this.collapsedPackages.add(packageId);
      
      const container = document.getElementById(`resources-${packageId}`);
      const indicator = document.getElementById(`indicator-${packageId}`);
      if (container && indicator) {
        const collapsed = this.collapsedPackages.has(packageId);
        container.classList.toggle('collapsed', collapsed);
        indicator.classList.toggle('collapsed', collapsed);
      }
    }

    bulkTogglePackage(packageId, enable) {
      const pack = this.packageGroups[packageId]; 
      if (!pack) return;
      
      pack.resources.forEach(async (r) => {
        await this.toggleResource(r.resource_id, enable);
        const cb = document.querySelector(`input[data-resource="${r.resource_id}"]`);
        if (cb) cb.checked = enable;
      });
    }

    setupEventListeners() {
      const searchInput = document.getElementById('layerSearch');
      let t; 
      searchInput.addEventListener('input', () => {
        clearTimeout(t); 
        t = setTimeout(() => { this.filterLayers(); }, 250);
      });
    }

    filterLayers() {
      const term = document.getElementById('layerSearch').value.toLowerCase();
      const container = document.getElementById('spatialLayersContainer');
      const filtered = this.spatialData.filter(r =>
        r.package_title.toLowerCase().includes(term) ||
        r.resource_name.toLowerCase().includes(term) ||
        (r.format || '').toLowerCase().includes(term)
      );

      const grouped = {};
      filtered.forEach(res => {
        if (!grouped[res.package_id]) grouped[res.package_id] = { ...this.packageGroups[res.package_id], resources: [] };
        grouped[res.package_id].resources.push(res);
      });

      container.innerHTML = Object.values(grouped).map(g => this.renderPackageGroup(g)).join('');
    }

    renderLayers() {
      const container = document.getElementById('spatialLayersContainer');
      if (this.spatialData.length === 0) {
        container.innerHTML = `<div class="error-section">Hen√ºz mekansal kaynak bulunamadƒ±.<br><small>Y√∂netim panelinden kaynaklarƒ± mekansal olarak i≈üaretleyin.</small></div>`;
        return;
      }
      const html = Object.values(this.packageGroups).map(pg => this.renderPackageGroup(pg)).join('');
      container.innerHTML = html;
    }

    renderPackageGroup(group) {
      const isCollapsed = this.collapsedPackages.has(group.id);
      const filteredResources = group.resources || [];
      if (filteredResources.length === 0) return '';
      
      return `
        <div class="package-group" id="package-${group.id}">
          <div class="package-header" onclick="spatialMapManager.togglePackageCollapse('${group.id}')">
            <div class="package-title-row">
              <h4 class="package-title">${group.name}</h4>
              <button class="collapse-indicator ${isCollapsed ? 'collapsed' : ''}" id="indicator-${group.id}">‚ñº</button>
            </div>
            <div class="package-meta">
              <span class="resource-count">${filteredResources.length} kaynak</span>
            </div>
          </div>
          <div class="resources-container ${isCollapsed ? 'collapsed' : ''}" id="resources-${group.id}">
            ${filteredResources.map(r => this.renderResourceItem(r)).join('')}
            <div class="bulk-actions">
              <button class="bulk-btn" onclick="spatialMapManager.bulkTogglePackage('${group.id}', true)">T√ºm√ºn√º A√ß</button>
              <button class="bulk-btn" onclick="spatialMapManager.bulkTogglePackage('${group.id}', false)">T√ºm√ºn√º Kapat</button>
            </div>
          </div>
        </div>`;
    }

    renderResourceItem(resource) {
      const format = (resource.format || 'other').toLowerCase();
      const formatClass = this.getFormatClass(format);
      const activeClass = this.activeResources.has(resource.resource_id) ? 'active' : '';
      return `
        <div class="resource-item ${activeClass}" id="resource-${resource.resource_id}">
          <div class="resource-info">
            <div class="resource-name" title="${resource.resource_name}">${resource.resource_name}</div>
            <div class="resource-meta"><span class="format-badge ${formatClass}">${format.toUpperCase()}</span></div>
          </div>
          <label class="modern-toggle">
            <input type="checkbox" data-resource="${resource.resource_id}" onchange="spatialMapManager.toggleResource('${resource.resource_id}', this.checked)">
            <span class="toggle-slider"></span>
          </label>
        </div>`;
    }

    getFormatClass(format) {
      const map = { 
        'csv':'format-csv',
        'json':'format-json',
        'geojson':'format-geojson',
        'xlsx':'format-xlsx',
        'xls':'format-xlsx',
        'shp':'format-shp',
        'kml':'format-kml',
        'api':'format-api',
        'rest':'format-api',
        'wms':'format-wms',
        'geotiff':'format-geotiff' 
      };
      return map[format] || 'format-other';
    }

    updateStats() {
      const totalResources = this.spatialData.length;
      const totalPackages = Object.keys(this.packageGroups).length;
      const activeResourceCount = this.activeResources.size;
      const totalFormats = [...new Set(this.spatialData.map(r => r.format))].filter(Boolean).length;

      document.getElementById('totalSpatialResources').textContent = totalResources.toLocaleString('tr-TR');
      document.getElementById('totalSpatialPackages').textContent = totalPackages.toLocaleString('tr-TR');
      document.getElementById('activeLayers').textContent = activeResourceCount.toLocaleString('tr-TR');
      document.getElementById('totalFormats').textContent = totalFormats.toLocaleString('tr-TR');
    }

    /* Kolon se√ßimi modalƒ± */
    showManualColumnSelection(resourceId, columns) {
      return new Promise((resolve) => {
        const modal = document.createElement('div');
        modal.className = 'column-modal-overlay';
        modal.innerHTML = `
          <style>
            .column-modal-overlay{position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.5);z-index:2000;display:flex;align-items:center;justify-content:center;}
            .column-modal{background:#fff;padding:22px;border-radius:12px;max-width:450px;width:90%;box-shadow:0 10px 30px rgba(0,0,0,0.2);}
            .column-modal h3{margin-bottom:16px;color:#2c3e50;font-size:18px;}
            .column-select-group{margin:12px 0;}
            .column-select-group label{display:block;margin-bottom:8px;font-weight:500;color:#495057;}
            .column-select-group select{width:100%;padding:10px 12px;border:1px solid #ced4da;border-radius:6px;font-size:14px;background:#fff;}
            .modal-actions{margin-top:18px;display:flex;justify-content:flex-end;gap:10px;}
            .modal-btn{padding:10px 16px;border:none;border-radius:6px;font-weight:500;cursor:pointer}
            .modal-btn.cancel{background:#6c757d;color:#fff;}
            .modal-btn.primary{background:#007bff;color:#fff;}
            .modal-btn:hover{opacity:.9;}
          </style>
          <div class="column-modal">
            <h3>Koordinat S√ºtunlarƒ±nƒ± Se√ßin</h3>
            <div class="column-select-group">
              <label>Enlem (Latitude) S√ºtunu:</label>
              <select id="latColumn">
                <option value="">Se√ßiniz...</option>
                ${columns.map(col => `<option value="${col}">${col}</option>`).join('')}
              </select>
            </div>
            <div class="column-select-group">
              <label>Boylam (Longitude) S√ºtunu:</label>
              <select id="lonColumn">
                <option value="">Se√ßiniz...</option>
                ${columns.map(col => `<option value="${col}">${col}</option>`).join('')}
              </select>
            </div>
            <div class="modal-actions">
              <button class="modal-btn cancel" onclick="this.closest('.column-modal-overlay').remove()">ƒ∞ptal</button>
              <button class="modal-btn primary" onclick="spatialMapManager.processManualSelection('${resourceId}', this)">Uygula</button>
            </div>
          </div>`;

        document.body.appendChild(modal);
        resolve();
      });
    }

    showError(message) {
      const container = document.getElementById('spatialLayersContainer');
      container.innerHTML = `<div class="error-section">${message}</div>`;
    }
  }

  let spatialMapManager;
  document.addEventListener('DOMContentLoaded', () => {
    spatialMapManager = new SpatialMapManager();
  });
</script>

{% endblock %}