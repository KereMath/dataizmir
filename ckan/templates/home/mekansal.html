{% extends "page.html" %}

{% block subtitle %}{{ _('Mekansal Gösterim') }}{% endblock %}

{% block primary %}
 
 <style>
   /* CKAN arama formunu gizle */
   .search-form {
       display:none !important;
   }
   
   /* Genel Sıfırlama ve Kutu Boyutlandırma */
   * {
     margin: 0;
     padding: 0;
     box-sizing: border-box;
   }

   /* Temel Gövde Stilleri */
   body {
     font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
     background-color: #f8f9fa;
     color: #333;
   }

   /* Ana Konteyner */
   .spatial-container {
     position: relative;
     height: 100vh;
     overflow: hidden;
   }

   /* Floating Panel Toggle Button */
   .panel-toggle {
     position: fixed;
     top: 20px;
     left: 20px;
     z-index: 1005;
     background: #fff;
     border: none;
     border-radius: 50%;
     width: 50px;
     height: 50px;
     box-shadow: 0 4px 12px rgba(0,0,0,0.15);
     cursor: pointer;
     display: flex;
     align-items: center;
     justify-content: center;
     font-size: 20px;
     color: #495057;
     transition: all 0.3s ease;
   }

   .panel-toggle:hover {
     background: #f8f9fa;
     transform: scale(1.05);
   }

   .panel-toggle.active {
     background: #007bff;
     color: white;
   }

   /* Sliding Panel */
   .layers-panel {
     position: fixed;
     top: 0;
     left: -400px;
     width: 380px;
     height: 100vh;
     background: #fff;
     box-shadow: 2px 0 20px rgba(0,0,0,0.1);
     z-index: 1004;
     transition: left 0.3s ease;
     overflow: hidden;
     display: flex;
     flex-direction: column;
   }
   
   .layers-panel.open {
     left: 0;
   }

   /* Panel Header */
   .panel-header {
     background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
     color: white;
     padding: 20px;
     position: relative;
     border-bottom: 1px solid rgba(255,255,255,0.1);
   }

   .panel-title {
     font-size: 18px;
     font-weight: 600;
     margin-bottom: 15px;
   }

   .close-panel {
     position: absolute;
     top: 15px;
     right: 15px;
     background: none;
     border: none;
     color: white;
     font-size: 24px;
     cursor: pointer;
     padding: 5px;
     border-radius: 50%;
     transition: background 0.2s;
   }

   .close-panel:hover {
     background: rgba(255,255,255,0.1);
   }

   /* Stats Grid */
   .stats-grid {
     display: grid;
     grid-template-columns: 1fr 1fr;
     gap: 10px;
   }

   .stat-item {
     background: rgba(255,255,255,0.15);
     padding: 10px;
     border-radius: 8px;
     text-align: center;
     backdrop-filter: blur(10px);
   }

   .stat-number {
     font-size: 1.4rem;
     font-weight: 700;
     display: block;
   }

   .stat-label {
     font-size: 0.75rem;
     opacity: 0.9;
     margin-top: 3px;
   }

   /* Search Section */
   .search-section {
     padding: 20px;
     border-bottom: 1px solid #e9ecef;
   }

   .search-input {
     width: 100%;
     padding: 12px 16px;
     border: 1px solid #ced4da;
     border-radius: 8px;
     font-size: 14px;
     background-color: #fff;
     transition: all 0.15s ease;
   }

   .search-input:focus {
     outline: none;
     border-color: #007bff;
     box-shadow: 0 0 0 0.2rem rgba(0,123,255,.25);
   }

   /* Layers Content */
   .layers-content {
     flex: 1;
     overflow-y: auto;
     padding-bottom: 20px;
   }

   /* Package Group Styles */
   .package-group {
     margin: 0 20px 15px 20px;
     border: 1px solid #e9ecef;
     border-radius: 12px;
     overflow: hidden;
     background: white;
     box-shadow: 0 2px 4px rgba(0,0,0,0.05);
   }

   .package-header {
     background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
     padding: 15px;
     cursor: pointer;
     user-select: none;
     transition: all 0.2s ease;
     border-bottom: 1px solid rgba(0,0,0,0.05);
   }

   .package-header:hover {
     background: linear-gradient(135deg, #e9ecef 0%, #dee2e6 100%);
   }

   .package-title-row {
     display: flex;
     justify-content: space-between;
     align-items: center;
     margin-bottom: 8px;
   }

   .package-title {
     font-size: 15px;
     font-weight: 600;
     color: #2c3e50;
     margin: 0;
     flex: 1;
     line-height: 1.3;
   }

   .collapse-indicator {
     background: none;
     border: none;
     font-size: 18px;
     color: #6c757d;
     cursor: pointer;
     padding: 4px;
     border-radius: 4px;
     transition: all 0.3s ease;
   }

   .collapse-indicator:hover {
     background: rgba(108, 117, 125, 0.1);
   }

   .collapse-indicator.collapsed {
     transform: rotate(-90deg);
   }

   .package-meta {
     display: flex;
     align-items: center;
     gap: 10px;
   }

   .resource-count {
     background: #28a745;
     color: white;
     padding: 3px 8px;
     border-radius: 12px;
     font-size: 11px;
     font-weight: 600;
   }

   /* Resources Container */
   .resources-container {
     display: block;
     max-height: 400px;
     overflow-y: auto;
   }

   .resources-container.collapsed {
     display: none;
   }

   /* Resource Item */
   .resource-item {
     display: flex;
     align-items: center;
     justify-content: space-between;
     padding: 12px 15px;
     border-bottom: 1px solid #f1f3f4;
     transition: all 0.2s ease;
     cursor: pointer;
   }

   .resource-item:last-child {
     border-bottom: none;
   }

   .resource-item:hover {
     background: #f8f9fa;
   }

   .resource-item.active {
     background: linear-gradient(135deg, #e3f2fd 0%, #f0f8ff 100%);
     border-left: 4px solid #1976d2;
   }
   
   .resource-item.wms-active {
     background: linear-gradient(135deg, #d6eaff 0%, #f0f8ff 100%) !important;
     border-left: 4px solid #2a61a0 !important;
   }

   .resource-info {
     flex: 1;
     min-width: 0;
   }

   .resource-name {
     font-size: 13px;
     font-weight: 500;
     color: #495057;
     margin: 0 0 5px 0;
     white-space: nowrap;
     overflow: hidden;
     text-overflow: ellipsis;
   }

   .resource-meta {
     display: flex;
     align-items: center;
     gap: 8px;
   }

   .format-badge {
     display: inline-block;
     padding: 2px 6px;
     border-radius: 4px;
     font-size: 9px;
     font-weight: 600;
     text-transform: uppercase;
   }

   /* Format Colors */
   .format-geojson { background: #d1ecf1; color: #0c5460; }
   .format-shp { background: #dcfce7; color: #166534; }
   .format-kml { background: #ddd6fe; color: #5b21b6; }
   .format-csv { background: #d4edda; color: #155724; }
   .format-json { background: #fff3cd; color: #856404; }
   .format-api { background: #f0f9ff; color: #0c4a6e; }
   .format-xlsx { background: #e2e3e5; color: #383d41; }
   .format-other { background: #f1f5f9; color: #475569; }
   .format-wms { background: #d6eaff; color: #2a61a0; }
   .format-geotiff { background: #fdf6e3; color: #b58900; }


   /* Modern Toggle Switch */
   .modern-toggle {
     position: relative;
     display: inline-block;
     width: 44px;
     height: 24px;
     margin-left: 10px;
   }

   .modern-toggle input {
     opacity: 0;
     width: 0;
     height: 0;
   }

   .toggle-slider {
     position: absolute;
     cursor: pointer;
     top: 0;
     left: 0;
     right: 0;
     bottom: 0;
     background: linear-gradient(135deg, #ddd, #ccc);
     transition: all .3s ease;
     border-radius: 24px;
     box-shadow: inset 0 2px 4px rgba(0,0,0,0.1);
   }

   .toggle-slider:before {
     position: absolute;
     content: "";
     height: 18px;
     width: 18px;
     left: 3px;
     bottom: 3px;
     background: white;
     transition: all .3s ease;
     border-radius: 50%;
     box-shadow: 0 2px 6px rgba(0,0,0,0.2);
   }

   input:checked + .toggle-slider {
     background: linear-gradient(135deg, #28a745, #20c997);
   }
   
   .wms-resource input:checked + .toggle-slider {
     background: linear-gradient(135deg, #2a61a0, #4c82c2);
   }
   .geotiff-resource input:checked + .toggle-slider {
     background: linear-gradient(135deg, #b58900, #cb9700);
   }

   input:checked + .toggle-slider:before {
     transform: translateX(20px);
   }

   /* Bulk Actions */
   .bulk-actions {
     padding: 12px 15px;
     background: rgba(248, 249, 250, 0.8);
     border-top: 1px solid #dee2e6;
     display: flex;
     gap: 8px;
   }

   .bulk-btn {
     flex: 1;
     padding: 6px 12px;
     border: 1px solid #dee2e6;
     border-radius: 6px;
     font-size: 11px;
     font-weight: 600;
     background: white;
     color: #495057;
     cursor: pointer;
     transition: all 0.2s ease;
   }

   .bulk-btn:hover {
     background: #007bff;
     color: white;
     border-color: #007bff;
   }

   /* Map Container */
   #map {
     height: 100vh;
     width: 100%;
     border-radius: 0;
     z-index: 0;
   }

   /* Loading ve Error */
   .loading-section, .error-section {
     text-align: center;
     padding: 40px 20px;
     color: #6c757d;
   }

   .error-section {
     background: #f8d7da;
     color: #721c24;
     margin: 20px;
     border-radius: 8px;
   }

   /* Panel Overlay */
   .panel-overlay {
     position: fixed;
     top: 0;
     left: 0;
     width: 100%;
     height: 100%;
     background: rgba(0,0,0,0.3);
     z-index: 1003;
     opacity: 0;
     visibility: hidden;
     transition: all 0.3s ease;
   }

   .panel-overlay.active {
     opacity: 1;
     visibility: visible;
   }

   /* Popup Stilleri */
   .popup-content {
     max-width: 280px;
     font-size: 12px;
     line-height: 1.4;
   }

   .popup-content > div {
     margin-bottom: 6px;
     word-wrap: break-word;
   }

   .popup-resource-header {
     background: linear-gradient(135deg, #007bff, #0056b3);
     color: white;
     padding: 8px 12px;
     margin: -8px -12px 8px -12px;
     border-radius: 4px 4px 0 0;
     font-weight: 600;
   }

   /* Column Selection Modal */
   .column-modal-overlay {
     position: fixed;
     top: 0;
     left: 0;
     width: 100%;
     height: 100%;
     background: rgba(0,0,0,0.5);
     z-index: 2000;
     display: none; /* Initially hidden */
     align-items: center;
     justify-content: center;
   }

   .column-modal {
     background: white;
     padding: 25px;
     border-radius: 12px;
     max-width: 450px;
     width: 90%;
     box-shadow: 0 10px 30px rgba(0,0,0,0.2);
   }

   .column-modal h3 {
     margin-bottom: 20px;
     color: #2c3e50;
     font-size: 18px;
   }

   .column-select-group {
     margin: 15px 0;
   }

   .column-select-group label {
     display: block;
     margin-bottom: 8px;
     font-weight: 500;
     color: #495057;
   }

   .column-select-group select {
     width: 100%;
     padding: 10px 12px;
     border: 1px solid #ced4da;
     border-radius: 6px;
     font-size: 14px;
     background: white;
   }

   .modal-actions {
     margin-top: 25px;
     display: flex;
     justify-content: flex-end;
     gap: 10px;
   }

   .modal-btn {
     padding: 10px 20px;
     border: none;
     border-radius: 6px;
     font-weight: 500;
     cursor: pointer;
     transition: all 0.2s;
   }

   .modal-btn.cancel {
     background: #6c757d;
     color: white;
   }

   .modal-btn.primary {
     background: #007bff;
     color: white;
   }

   .modal-btn:hover {
     opacity: 0.9;
   }
   
   /* Responsive */
   @media (max-width: 768px) {
     .layers-panel {
       width: 100%;
       left: -100%;
     }
     
     .panel-toggle {
       top: 15px;
       left: 15px;
       width: 45px;
       height: 45px;
     }
     
     .stats-grid {
       grid-template-columns: 1fr;
       gap: 8px;
     }
     
     .package-group {
       margin: 0 15px 12px 15px;
     }
   }
 </style>

 <div class="spatial-container">
   <button class="panel-toggle" id="panelToggle" onclick="spatialMapManager.togglePanel()">
     <span id="toggleIcon">☰</span>
   </button>

   <div class="panel-overlay" id="panelOverlay" onclick="spatialMapManager.closePanel()"></div>

   <div class="layers-panel" id="layersPanel">
     <div class="panel-header">
       <button class="close-panel" onclick="spatialMapManager.closePanel()">×</button>
       <div class="panel-title">Mekansal Katmanlar</div>
       <div class="stats-grid">
         <div class="stat-item">
           <span class="stat-number" id="totalSpatialResources">-</span>
           <div class="stat-label">Kaynak</div>
         </div>
         <div class="stat-item">
           <span class="stat-number" id="totalSpatialPackages">-</span>
           <div class="stat-label">Paket</div>
         </div>
         <div class="stat-item">
           <span class="stat-number" id="activeLayers">-</span>
           <div class="stat-label">Aktif Katman</div>
         </div>
         <div class="stat-item">
           <span class="stat-number" id="totalFormats">-</span>
           <div class="stat-label">Format</div>
         </div>
       </div>
     </div>

     <div class="search-section">
       <input type="search" class="search-input" id="layerSearch" placeholder="Katman ara...">
     </div>

     <div class="layers-content" id="spatialLayersContainer">
       <div class="loading-section">Mekansal katmanlar yükleniyor...</div>
     </div>
   </div>

   <div id="map"></div>

   <div class="column-modal-overlay" id="column-modal-overlay">
      <div class="column-modal">
        <h3 id="modal-title">Koordinat Sütunlarını Seçin</h3>
        <div id="modal-info"></div>
        <div class="column-select-group">
          <label>Enlem (Latitude) Sütunu:</label>
          <select id="latColumnSelect"></select>
        </div>
        <div class="column-select-group">
          <label>Boylam (Longitude) Sütunu:</label>
          <select id="lonColumnSelect"></select>
        </div>
        <div class="modal-actions">
          <button id="modal-cancel-btn" class="modal-btn cancel">İptal</button>
          <button id="modal-apply-btn" class="modal-btn primary">Uygula</button>
        </div>
      </div>
   </div>
 </div>

 <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
 <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
 <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet-omnivore/0.3.4/leaflet-omnivore.min.js"></script>
 <script src="https://unpkg.com/shpjs@3.6.0/dist/shp.min.js"></script>
 <script src="https://unpkg.com/papaparse@5.3.2/papaparse.min.js"></script>

 <script src="https://unpkg.com/georaster@1.5.6/dist/georaster.browser.bundle.min.js"></script>
 <script src="https://unpkg.com/georaster-layer-for-leaflet@3.10.0/dist/georaster-layer-for-leaflet.min.js"></script>
 <script src="https://unpkg.com/geotiff@2.0.7/dist/geotiff.bundle.min.js"></script>

 <script>
   console.log('Modern Mekansal Görüntüleme Sistemi Başlıyor');

   class SpatialMapManager {
     constructor() {
       this.map = null;
       this.spatialData = [];
       this.packageGroups = {};
       this.resourceLayers = {};
       this.activeResources = new Set();
       this.init();
     }

     async init() {
       try {
         this.initMap();
         await this.loadSpatialData();
         this.setupEventListeners();
         this.renderLayers();
         this.updateStats();
       } catch (error) {
         console.error('Initialization hatası:', error);
         this.showError('Mekansal veriler yüklenirken hata oluştu.');
       }
     }

     initMap() {
       this.map = L.map('map').setView([38.4237, 27.1428], 10);
       L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
         maxZoom: 19,
         attribution: '© OpenStreetMap'
       }).addTo(this.map);
     }

     async loadSpatialData() {
       try {
         const response = await fetch('/api/spatial-resources/list', { credentials: 'include' });
         const data = await response.json();
         if (!data.success) throw new Error(data.error);
         this.spatialData = data.spatial_resources || [];
         this.createPackageGroups();
       } catch (error) {
         console.error('Spatial data yükleme hatası:', error);
         throw error;
       }
     }
     
     createPackageGroups() {
        this.packageGroups = {};
        this.spatialData.forEach(resource => {
            if (!this.packageGroups[resource.package_id]) {
                this.packageGroups[resource.package_id] = {
                    id: resource.package_id,
                    name: resource.package_title,
                    package_name: resource.package_name,
                    resources: []
                };
            }
            this.packageGroups[resource.package_id].resources.push(resource);
            this.resourceLayers[resource.resource_id] = {
                resource: resource,
                layer: L.layerGroup(),
                visible: false,
                loaded: false
            };
        });
    }
    
    // ====================================================================
    // === 💡 YENİ VE GÜNCELLENMİŞ VERİ YÜKLEME FONKSİYONU 💡 ===
    // ====================================================================
    async loadResourceData(resourceId) {
        const resourceLayer = this.resourceLayers[resourceId];
        if (!resourceLayer || resourceLayer.loaded) return;

        const { url, format } = resourceLayer.resource;
        const formatLower = (format || '').toLowerCase();
        
        this.showLoadingForResource(resourceId);

        try {
            let geojsonData;

            if (['wms', 'wfs', 'geotiff'].includes(formatLower)) {
                await this.addLayerFromUrl(url, formatLower, resourceLayer.layer, resourceId);
            } else if (['shp', 'zip'].includes(formatLower)) {
                geojsonData = await this.processShpData(url);
            } else if (formatLower === 'geojson') {
                geojsonData = await this.fetchJson(url);
            } else if (['api', 'json'].includes(formatLower)) {
                let data = await this.fetchJson(url);
                geojsonData = this.autoParseJsonData(data);
                if (!geojsonData) {
                    throw new Error("JSON verisi GeoJSON formatına dönüştürülemedi.");
                }
            } else if (formatLower === 'csv') {
                const textData = await this.fetchText(url);
                const columns = this.getCsvColumns(textData);
                const coordCols = await this.showManualColumnSelection(resourceId, columns, textData);
                geojsonData = this.convertCsvToGeoJSON(textData, coordCols.lat, coordCols.lon);
            } else {
                throw new Error(`Desteklenmeyen format: ${format}`);
            }

            if (geojsonData) {
                this.addGeoJSONToLayer(geojsonData, resourceLayer.layer, resourceId);
            }
            
            resourceLayer.loaded = true;

        } catch (error) {
            console.error('[DEBUG] Veri işleme hatası:', error);
            this.showResourceError(resourceId, `Veri yüklenemedi: ${error.message}`);
            
            // Hata durumunda checkbox'ı geri al
            const checkbox = document.querySelector(`input[data-resource="${resourceId}"]`);
            if (checkbox) checkbox.checked = false;
        } finally {
            this.hideLoadingForResource(resourceId);
        }
    }
    
    // --- Yardımcı Fetch Fonksiyonları ---
    async fetchJson(url) {
        const response = await fetch(url, { mode: 'cors' });
        if (!response.ok) throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        return await response.json();
    }
    
    async fetchText(url) {
        const response = await fetch(url, { mode: 'cors' });
        if (!response.ok) throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        return await response.text();
    }

    async fetchArrayBuffer(url) {
        const response = await fetch(url);
        if (!response.ok) throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        return await response.arrayBuffer();
    }

    // --- Veri İşleme Fonksiyonları ---
    async processShpData(shpUrl) {
       const buffer = await this.fetchArrayBuffer(shpUrl);
       const geojson = shp.parseZip(buffer);
       if (!geojson || !geojson.features || geojson.features.length === 0) {
           throw new Error('SHP dosyasında mekansal veri bulunamadı.');
       }
       return geojson;
    }

    autoParseJsonData(data) {
        if (data.type === 'FeatureCollection') return data;
        
        let records = [];
        if (Array.isArray(data)) {
            records = data;
        } else if (typeof data === 'object') {
            const possibleKeys = ['features', 'data', 'results', 'items', 'onemliyer', 'records'];
            for (const key of possibleKeys) {
                if (Array.isArray(data[key])) {
                    records = data[key];
                    break;
                }
            }
        }
        
        if (records.length === 0) return null;

        const firstRecord = records[0];
        if (firstRecord.type === 'Feature') { // GeoJSON feature listesi
             return { type: 'FeatureCollection', features: records };
        }

        const coordCols = this.smartDetectCoordinateColumns(Object.keys(firstRecord));
        if (!coordCols.lat || !coordCols.lon) return null;

        const features = records.map(row => {
            const lat = parseFloat(String(row[coordCols.lat]).replace(',', '.'));
            const lon = parseFloat(String(row[coordCols.lon]).replace(',', '.'));
            if (isNaN(lat) || isNaN(lon)) return null;
            
            const properties = { ...row };
            delete properties[coordCols.lat];
            delete properties[coordCols.lon];

            return {
                type: 'Feature',
                geometry: { type: 'Point', coordinates: [lon, lat] },
                properties: properties
            };
        }).filter(f => f !== null);

        return { type: 'FeatureCollection', features: features };
    }

    getCsvColumns(textData) {
        let columns = [];
        Papa.parse(textData, {
            header: true,
            preview: 1,
            complete: (results) => {
                columns = results.meta.fields || [];
            }
        });
        return columns;
    }

    convertCsvToGeoJSON(textData, latCol, lonCol) {
        const features = [];
        Papa.parse(textData, {
            header: true,
            skipEmptyLines: true,
            complete: (results) => {
                results.data.forEach(row => {
                    const lat = parseFloat(String(row[latCol]).replace(',', '.'));
                    const lon = parseFloat(String(row[lonCol]).replace(',', '.'));

                    if (!isNaN(lat) && !isNaN(lon)) {
                        const properties = { ...row };
                        delete properties[latCol];
                        delete properties[lonCol];

                        features.push({
                            type: 'Feature',
                            geometry: { type: 'Point', coordinates: [lon, lat] },
                            properties: properties
                        });
                    }
                });
            }
        });
        return { type: 'FeatureCollection', features: features };
    }

    smartDetectCoordinateColumns(columns) {
        const latPatterns = [/^(lat|latitude|enlem|y_koordinat|y)$/i, /lat/i, /enlem/i, /koordinat/i];
        const lonPatterns = [/^(lon|lng|longitude|boylam|x_koordinat|x)$/i, /lon/i, /boylam/i, /koordinat/i];
        let lat, lon;

        for (const pattern of latPatterns) {
            lat = columns.find(c => pattern.test(c));
            if (lat) break;
        }
        for (const pattern of lonPatterns) {
            lon = columns.find(c => pattern.test(c) && c !== lat);
            if (lon) break;
        }
        return { lat, lon };
    }

    showManualColumnSelection(resourceId, columns) {
        return new Promise((resolve, reject) => {
            const modal = document.getElementById('column-modal-overlay');
            const latSelect = document.getElementById('latColumnSelect');
            const lonSelect = document.getElementById('lonColumnSelect');
            const applyBtn = document.getElementById('modal-apply-btn');
            const cancelBtn = document.getElementById('modal-cancel-btn');
            
            latSelect.innerHTML = lonSelect.innerHTML = '<option value="">Seçiniz...</option>' + columns.map(c => `<option value="${c}">${c}</option>`).join('');

            const autoCols = this.smartDetectCoordinateColumns(columns);
            if (autoCols.lat) latSelect.value = autoCols.lat;
            if (autoCols.lon) lonSelect.value = autoCols.lon;

            modal.style.display = 'flex';

            const onApply = () => {
                const lat = latSelect.value;
                const lon = lonSelect.value;
                if (lat && lon) {
                    modal.style.display = 'none';
                    cleanup();
                    resolve({ lat, lon });
                } else {
                    alert('Lütfen hem enlem hem boylam sütununu seçin.');
                }
            };
            
            const onCancel = () => {
                modal.style.display = 'none';
                cleanup();
                reject(new Error("Kullanıcı koordinat seçimini iptal etti."));
            };
            
            const cleanup = () => {
                applyBtn.removeEventListener('click', onApply);
                cancelBtn.removeEventListener('click', onCancel);
            };
            
            applyBtn.addEventListener('click', onApply);
            cancelBtn.addEventListener('click', onCancel);
        });
    }

    // ====================================================================
    // === Diğer fonksiyonlar (çoğunlukla aynı kalabilir) ===
    // ====================================================================

    async addLayerFromUrl(url, format, layerGroup, resourceId) {
       // ... (Bu fonksiyon aynı kalabilir)
    }

     async processGeoTiffData(url, resourceId) {
       // ... (Bu fonksiyon aynı kalabilir)
     }

     showResourceError(resourceId, errorMessage) {
       const resourceElement = document.getElementById(`resource-${resourceId}`);
       if (resourceElement) {
         const resourceInfo = resourceElement.querySelector('.resource-info');
         if (resourceInfo) {
           let errorDiv = resourceInfo.querySelector('.resource-error');
           if (!errorDiv) {
               errorDiv = document.createElement('div');
               errorDiv.className = 'resource-error';
               errorDiv.style.cssText = 'color: #dc3545; font-size: 11px; margin-top: 4px; font-style: italic; white-space: normal; line-height: 1.3;';
               resourceInfo.appendChild(errorDiv);
           }
           errorDiv.textContent = errorMessage.length > 100 ? errorMessage.substring(0, 100) + '...' : errorMessage;
           errorDiv.title = errorMessage;
         }
       }
     }

     addGeoJSONToLayer(geojsonData, layerGroup, resourceId) {
        try {
            layerGroup.clearLayers();
            const resource = this.resourceLayers[resourceId].resource;
            const color = this.getResourceColor(resourceId);

            if (!geojsonData || !geojsonData.features) throw new Error("Geçersiz GeoJSON verisi");

            const geoJsonLayer = L.geoJSON(geojsonData, {
                pointToLayer: (feature, latlng) => L.circleMarker(latlng, {
                    radius: 7, fillColor: color, color: '#fff', weight: 1.5, opacity: 1, fillOpacity: 0.8
                }),
                style: (feature) => ({
                    color: color, weight: 2, opacity: 0.8, fillColor: color, fillOpacity: 0.3
                }),
                onEachFeature: (feature, layer) => {
                    layer.bindPopup(this.createPopupContent(feature, resource));
                }
            });
            layerGroup.addLayer(geoJsonLayer);
        } catch (error) {
            console.error('[DEBUG] GeoJSON ekleme hatası:', error);
            this.showResourceError(resourceId, `GeoJSON işlenemedi: ${error.message}`);
        }
     }

     createPopupContent(feature, resource) {
        let content = `<div class="popup-content"><div class="popup-resource-header">${resource.resource_name}</div>`;
        if (feature.properties) {
            Object.entries(feature.properties).forEach(([key, value]) => {
                if (value) content += `<div><strong>${key}:</strong> ${value}</div>`;
            });
        }
        content += `<div style="margin-top:8px; padding-top:8px; border-top:1px solid #eee; text-align:center;"><a href="/dataset/${resource.package_name}/resource/${resource.resource_id}" target="_blank">Kaynağı Görüntüle →</a></div></div>`;
        return content;
     }

     showLoadingForResource(resourceId) {
        const toggle = document.querySelector(`#resource-${resourceId} .toggle-slider`);
        if (toggle) toggle.style.background = 'linear-gradient(135deg, #ffc107, #e0a800)';
     }

     hideLoadingForResource(resourceId) {
        const el = document.getElementById(`resource-${resourceId}`);
        if(el) {
            const checkbox = el.querySelector('input[type="checkbox"]');
            const toggle = el.querySelector('.toggle-slider');
            if (toggle && checkbox) {
                toggle.style.background = checkbox.checked ? 'linear-gradient(135deg, #28a745, #20c997)' : 'linear-gradient(135deg, #ddd, #ccc)';
            }
        }
     }

     getResourceColor(resourceId) {
        const colors = ['#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', '#FECA57', '#FF9FF3', '#54A0FF', '#5F27CD'];
        let hash = 0;
        for (let i = 0; i < resourceId.length; i++) {
            hash = resourceId.charCodeAt(i) + ((hash << 5) - hash);
        }
        return colors[Math.abs(hash) % colors.length];
     }
     
     async toggleResource(resourceId, isVisible) {
        const resourceLayer = this.resourceLayers[resourceId];
        if (!resourceLayer) return;

        if (isVisible) {
            if (!resourceLayer.loaded) await this.loadResourceData(resourceId);
            if (resourceLayer.loaded) {
                resourceLayer.layer.addTo(this.map);
                this.activeResources.add(resourceId);
                resourceLayer.visible = true;
            }
        } else {
            this.map.removeLayer(resourceLayer.layer);
            this.activeResources.delete(resourceId);
            resourceLayer.visible = false;
        }

        document.getElementById(`resource-${resourceId}`)?.classList.toggle('active', isVisible);
        this.updateStats();
        this.fitMapToActiveLayers();
    }

     fitMapToActiveLayers() {
        if (this.activeResources.size === 0) return;
        const group = new L.featureGroup();
        this.activeResources.forEach(id => {
            const layer = this.resourceLayers[id].layer;
            if (layer.getLayers().length > 0) group.addLayer(layer);
        });
        if (group.getLayers().length > 0) this.map.fitBounds(group.getBounds().pad(0.1));
    }

togglePanel() {
        const panel = document.getElementById('layersPanel');
        const overlay = document.getElementById('panelOverlay');
        const toggleButton = document.getElementById('panelToggle');
        const icon = document.getElementById('toggleIcon');

        // Class'ları değiştir
        panel.classList.toggle('open');
        overlay.classList.toggle('active');
        toggleButton.classList.toggle('active');

        // 💡 İkonu durumuna göre değiştir (eklenen kısım)
        if (panel.classList.contains('open')) {
            icon.textContent = '×';
        } else {
            icon.textContent = '☰';
        }
     }

     closePanel() {
        document.getElementById('layersPanel').classList.remove('open');
        document.getElementById('panelOverlay').classList.remove('active');
        document.getElementById('panelToggle').classList.remove('active');
        
        // 💡 İkonu her zaman başlangıç durumuna getir (eklenen kısım)
        document.getElementById('toggleIcon').textContent = '☰';
     }
    togglePackageCollapse(packageId) { document.getElementById(`resources-${packageId}`).classList.toggle('collapsed'); document.getElementById(`indicator-${packageId}`).classList.toggle('collapsed'); }

     bulkTogglePackage(packageId, enable) {
        this.packageGroups[packageId].resources.forEach(res => {
            const checkbox = document.querySelector(`input[data-resource="${res.resource_id}"]`);
            if (checkbox && checkbox.checked !== enable) {
                checkbox.checked = enable;
                this.toggleResource(res.resource_id, enable);
            }
        });
     }

     setupEventListeners() {
       document.getElementById('layerSearch').addEventListener('input', (e) => this.filterLayers(e.target.value));
       document.getElementById('panelToggle').addEventListener('click', () => this.togglePanel());
       document.getElementById('panelOverlay').addEventListener('click', () => this.closePanel());
       document.querySelector('.close-panel').addEventListener('click', () => this.closePanel());
     }

     filterLayers(searchTerm) {
        const term = searchTerm.toLowerCase().trim();
        document.querySelectorAll('.package-group').forEach(group => {
            let hasVisibleResource = false;
            group.querySelectorAll('.resource-item').forEach(item => {
                const name = item.querySelector('.resource-name').textContent.toLowerCase();
                const format = item.querySelector('.format-badge').textContent.toLowerCase();
                const isMatch = name.includes(term) || format.includes(term);
                item.style.display = isMatch ? 'flex' : 'none';
                if (isMatch) hasVisibleResource = true;
            });
            group.style.display = hasVisibleResource ? 'block' : 'none';
        });
     }

     renderLayers() {
        const container = document.getElementById('spatialLayersContainer');
        if (this.spatialData.length === 0) {
            container.innerHTML = `<div class="error-section">Mekansal kaynak bulunamadı.</div>`;
            return;
        }
        container.innerHTML = Object.values(this.packageGroups).map(g => this.renderPackageGroup(g)).join('');
     }
     
     renderPackageGroup(group) {
        return `
            <div class="package-group" id="package-${group.id}">
                <div class="package-header" onclick="spatialMapManager.togglePackageCollapse('${group.id}')">
                    <div class="package-title-row">
                        <h4 class="package-title">${group.name}</h4>
                        <button class="collapse-indicator" id="indicator-${group.id}">▼</button>
                    </div>
                    <div class="package-meta"><span class="resource-count">${group.resources.length} kaynak</span></div>
                </div>
                <div class="resources-container" id="resources-${group.id}">
                    ${group.resources.map(res => this.renderResourceItem(res)).join('')}
                    <div class="bulk-actions">
                        <button class="bulk-btn" onclick="spatialMapManager.bulkTogglePackage('${group.id}', true)">Tümünü Aç</button>
                        <button class="bulk-btn" onclick="spatialMapManager.bulkTogglePackage('${group.id}', false)">Tümünü Kapat</button>
                    </div>
                </div>
            </div>
        `;
    }

     renderResourceItem(resource) {
       const format = (resource.format || 'other').toLowerCase();
       return `
         <div class="resource-item" id="resource-${resource.resource_id}">
           <div class="resource-info">
             <div class="resource-name" title="${resource.resource_name}">${resource.resource_name}</div>
             <div class="resource-meta">
               <span class="format-badge ${this.getFormatClass(format)}">${format.toUpperCase()}</span>
             </div>
           </div>
           <label class="modern-toggle">
             <input type="checkbox" data-resource="${resource.resource_id}" onchange="spatialMapManager.toggleResource('${resource.resource_id}', this.checked)">
             <span class="toggle-slider"></span>
           </label>
         </div>
       `;
     }

     getFormatClass(format) {
       const f = { csv:'csv', json:'json', geojson:'geojson', xlsx:'xlsx', xls:'xlsx', shp:'shp', kml:'kml', api:'api', wms:'wms', geotiff:'geotiff' };
       return `format-${f[format] || 'other'}`;
     }

     updateStats() {
       document.getElementById('totalSpatialResources').textContent = this.spatialData.length;
       document.getElementById('totalSpatialPackages').textContent = Object.keys(this.packageGroups).length;
       document.getElementById('activeLayers').textContent = this.activeResources.size;
       document.getElementById('totalFormats').textContent = [...new Set(this.spatialData.map(r => r.format))].filter(Boolean).length;
     }
   }

   let spatialMapManager;
   document.addEventListener('DOMContentLoaded', () => {
     spatialMapManager = new SpatialMapManager();
   });
 </script>

{% endblock %}