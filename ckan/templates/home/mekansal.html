{% extends "page.html" %}
<script src="https://unpkg.com/geotiff@2.0.7/dist/geotiff.bundle.min.js"></script>
{% block subtitle %}{{ _('Mekansal G√∂sterim') }}{% endblock %}

{%- block header %}
{% include "header.html" %}
<div id="title" class="package-title container-fluid"
  style="background-image:url(&quot;/base/images/theme/background_photo.jpg&quot;);color: #fff;">
  <div class="background-overlay">
    <div class="restricted-max-width">
      <div class="col-xs-12 col-md-10 col-md-offset-1">
        <div id="title-container" class="col-xs-10 col-md-6 text-left">
          <h1 style="margin-left: 200px;">Mekansal G√∂sterim</h1>
        </div>
        <div id="stats" class="col-xs-12 col-md-4 col-md-offset-2">
          <div class="col-xs-12" style="text-align: center;margin-top: 20px;font-size: 16px;">
          </div>
        </div>
      </div>
    </div>
  </div>
</div>
{%- endblock %}

{% block primary %}
<style>
  /* Site scroll'u kaldƒ±r */
  html,
  body {
    overflow: auto !important;
    height: auto !important;
  }

  #content {
    overflow: hidden !important;
  }

  .site-footer {
    display: none !important;
  }

  .search-form {
    display: none !important;
  }

  * {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
  }

  body {
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
    background-color: #f8f9fa;
    color: #333;
  }

  .page-container {
    display: flex;
    height: auto !important;
    overflow: hidden;
    position: relative !important;
    width: 100%;
  }

  .sidebar-filter {
    width: 360px;
    flex: 0 0 360px;
    background: #fff;
    border-right: 1px solid #e9ecef;
    z-index: 1;
    height: 100vh;
    display: flex;
    flex-direction: column;
  }

  .layers-panel {
    width: 100%;
    height: 100%;
    background: #fff;
    overflow: hidden;
    display: flex;
    flex-direction: column;
  }

  .panel-header {
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    color: white;
    padding: 20px;
    border-bottom: 1px solid rgba(255, 255, 255, 0.1);
    flex-shrink: 0;
  }

  .stats-grid {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 10px;
  }

  .stat-item {
    background: rgba(255, 255, 255, 0.15);
    padding: 12px 10px;
    border-radius: 8px;
    text-align: center;
    backdrop-filter: blur(10px);
  }

  .stat-number {
    font-size: 1.8rem;
    font-weight: 700;
    display: block;
  }

  .stat-label {
    font-size: 13px;
    opacity: 0.9;
    margin-top: 4px;
    font-weight: 500;
  }

  /* Filtreleme alanƒ± */
  .filter-section {
    padding: 12px 16px;
    background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
    border-bottom: 1px solid #dee2e6;
    flex-shrink: 0;
  }

  .filter-row {
    display: flex;
    gap: 8px;
    margin-bottom: 8px;
  }

  .filter-row:last-child {
    margin-bottom: 0;
  }

  .filter-select {
    flex: 1;
    padding: 8px 10px;
    border: 1px solid #ced4da;
    border-radius: 6px;
    font-size: 13px;
    background: white;
    cursor: pointer;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
    max-width: 100%;
  }

  .filter-select:focus {
    outline: none;
    border-color: #007bff;
    box-shadow: 0 0 0 0.2rem rgba(0, 123, 255, .15);
  }

  .filter-label {
    font-size: 11px;
    font-weight: 600;
    color: #6c757d;
    margin-bottom: 4px;
    text-transform: uppercase;
    letter-spacing: 0.5px;
  }

  .search-section {
    padding: 12px 16px;
    border-bottom: 1px solid #e9ecef;
    flex-shrink: 0;
  }

  .search-input {
    width: 100%;
    padding: 10px 12px;
    border: 1px solid #ced4da;
    border-radius: 8px;
    font-size: 14px;
    background-color: #fff;
  }

  .search-input:focus {
    outline: none;
    border-color: #007bff;
    box-shadow: 0 0 0 0.2rem rgba(0, 123, 255, .15);
  }

  .layers-content {
    flex: 1;
    overflow-y: auto;
    padding-bottom: 20px;
    min-height: 0;
  }

  .package-group {
    margin: 12px 16px;
    border: 1px solid #e9ecef;
    border-radius: 12px;
    overflow: hidden;
    background: white;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
  }

  .package-header {
    background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
    padding: 12px 14px;
    cursor: pointer;
    user-select: none;
    border-bottom: 1px solid rgba(0, 0, 0, 0.04);
    transition: background 0.2s;
  }

  .package-header:hover {
    background: linear-gradient(135deg, #e9ecef 0%, #dee2e6 100%);
  }

  .package-title-row {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 6px;
  }

  .package-title {
    font-size: 15px;
    font-weight: 600;
    color: #2c3e50;
    margin: 0;
    line-height: 1.3;
  }

  .collapse-indicator {
    background: none;
    border: none;
    font-size: 18px;
    color: #6c757d;
    cursor: pointer;
    padding: 4px;
    transition: transform 0.3s;
  }

  .collapse-indicator.collapsed {
    transform: rotate(-90deg);
  }

  .package-meta {
    display: flex;
    align-items: center;
    gap: 10px;
    flex-wrap: wrap;
  }

  .resource-count {
    background: #28a745;
    color: white;
    padding: 3px 8px;
    border-radius: 12px;
    font-size: 11px;
    font-weight: 600;
  }

  .theme-badge {
    background: #17a2b8;
    color: white;
    padding: 3px 8px;
    border-radius: 12px;
    font-size: 11px;
    font-weight: 600;
  }

  .category-badge {
    background: #6c757d;
    color: white;
    padding: 3px 8px;
    border-radius: 12px;
    font-size: 11px;
    font-weight: 600;
  }

  .resources-container {
    display: block;
    max-height: 400px;
    overflow-y: auto;
  }

  .resources-container.collapsed {
    display: none;
  }

  .resource-item {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 10px 12px;
    border-bottom: 1px solid #f1f3f4;
    cursor: default;
    transition: all 0.2s;
  }

  .resource-item:last-child {
    border-bottom: none;
  }

  .resource-item:hover {
    background: #f8f9fa;
  }

  .resource-item.active {
    background: linear-gradient(135deg, #e3f2fd 0%, #f0f8ff 100%);
    border-left: 4px solid #1976d2;
    padding-left: 8px;
  }

  .resource-info {
    flex: 1;
    min-width: 0;
    cursor: default;
  }

  .resource-name {
    font-size: 13px;
    font-weight: 500;
    color: #495057;
    margin: 0 0 5px 0;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }

  .resource-meta {
    display: flex;
    align-items: center;
    gap: 8px;
  }

  .format-badge {
    display: inline-block;
    padding: 2px 6px;
    border-radius: 4px;
    font-size: 9px;
    font-weight: 600;
    text-transform: uppercase;
  }

  .format-geojson {
    background: #d1ecf1;
    color: #0c5460;
  }

  .format-shp {
    background: #dcfce7;
    color: #166534;
  }

  .format-kml {
    background: #ddd6fe;
    color: #5b21b6;
  }

  .format-csv {
    background: #d4edda;
    color: #155724;
  }

  .format-json {
    background: #fff3cd;
    color: #856404;
  }

  .format-api {
    background: #f0f9ff;
    color: #0c4a6e;
  }

  .format-xlsx {
    background: #e2e3e5;
    color: #383d41;
  }

  .format-other {
    background: #f1f5f9;
    color: #475569;
  }

  .format-wms {
    background: #d6eaff;
    color: #2a61a0;
  }

  .format-geotiff {
    background: #fdf6e3;
    color: #b58900;
  }

  .resource-actions {
    display: flex;
    align-items: center;
    gap: 8px;
  }

  .download-resource-btn {
    padding: 6px 10px;
    background: #28a745;
    color: white;
    border: none;
    border-radius: 6px;
    cursor: pointer;
    font-size: 11px;
    display: flex;
    align-items: center;
    gap: 4px;
    transition: all 0.2s;
  }

  .download-resource-btn:hover {
    background: #218838;
    transform: translateY(-1px);
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.15);
  }

  .modern-toggle {
    position: relative;
    display: inline-block;
    width: 44px;
    height: 24px;
    cursor: pointer;
  }

  .modern-toggle input {
    opacity: 0;
    width: 0;
    height: 0;
  }

  .toggle-slider {
    position: absolute;
    cursor: pointer;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: linear-gradient(135deg, #ddd, #ccc);
    transition: all .3s ease;
    border-radius: 24px;
    box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.1);
  }

  .toggle-slider:before {
    position: absolute;
    content: "";
    height: 18px;
    width: 18px;
    left: 3px;
    bottom: 3px;
    background: white;
    transition: all .3s ease;
    border-radius: 50%;
    box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
  }

  input:checked+.toggle-slider {
    background: linear-gradient(135deg, #28a745, #20c997);
  }

  .wms-resource input:checked+.toggle-slider {
    background: linear-gradient(135deg, #2a61a0, #4c82c2);
  }

  .geotiff-resource input:checked+.toggle-slider {
    background: linear-gradient(135deg, #b58900, #cb9700);
  }

  input:checked+.toggle-slider:before {
    transform: translateX(20px);
  }

  .main-container {
    flex: 1;
    position: relative;
    height: 100vh;
    overflow: hidden;
  }

  #map {
    position: absolute;
    inset: 0;
    width: 100%;
    height: 100%;
    z-index: 0;
  }

  /* Map controls i√ßin alan a√ß */
  .leaflet-top.leaflet-left {
    left: 10px;
    top: 60px;
  }

  /* Harita taban se√ßici */
  .basemap-control {
    position: absolute;
    top: 10px;
    left: 10px;
    background: white;
    border-radius: 8px;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
    z-index: 1000;
    overflow: hidden;
  }

  .basemap-button {
    padding: 8px 12px;
    border: none;
    background: white;
    cursor: pointer;
    font-size: 13px;
    font-weight: 500;
    color: #495057;
    transition: all 0.2s;
    border-right: 1px solid #e9ecef;
  }

  .basemap-button:last-child {
    border-right: none;
  }

  .basemap-button:hover {
    background: #f8f9fa;
  }

  .basemap-button.active {
    background: #007bff;
    color: white;
  }

  /* Layer Switcher Control */
  .layer-switcher-control {
    position: absolute;
    top: 10px;
    right: 120px;
    background: white;
    border-radius: 8px;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
    z-index: 1000;
    min-width: 250px;
    max-width: 350px;
    max-height: 70vh;
    overflow-y: auto;
  }

  .layer-switcher-header {
    background: linear-gradient(135deg, #007bff, #0056b3);
    color: white;
    padding: 10px 15px;
    font-weight: 600;
    font-size: 14px;
    display: flex;
    justify-content: space-between;
    align-items: center;
  }

  .layer-switcher-toggle {
    background: none;
    border: none;
    color: white;
    cursor: pointer;
    font-size: 16px;
  }

  .layer-switcher-content {
    padding: 10px;
    display: none;
  }

  .layer-switcher-content.expanded {
    display: block;
  }

  .layer-switcher-item {
    display: flex;
    align-items: center;
    padding: 8px;
    border-bottom: 1px solid #f0f0f0;
  }

  .layer-switcher-item:last-child {
    border-bottom: none;
  }

  .layer-switcher-checkbox {
    margin-right: 10px;
  }

  .layer-switcher-label {
    flex: 1;
    font-size: 13px;
    color: #495057;
    cursor: pointer;
  }

  .layer-switcher-opacity {
    display: flex;
    align-items: center;
    gap: 5px;
    margin-left: 20px;
    padding: 5px 0;
  }

  .opacity-slider {
    flex: 1;
    cursor: pointer;
  }

  .opacity-value {
    font-size: 11px;
    color: #6c757d;
    min-width: 35px;
    text-align: right;
  }

  /* WMS Layer Info */
  .wms-layer-info {
    background: #f8f9fa;
    border-radius: 4px;
    padding: 8px;
    margin: 5px 0;
    font-size: 11px;
    color: #6c757d;
  }

  .wms-layer-list {
    list-style: none;
    padding: 0;
    margin: 5px 0;
  }

  .wms-layer-list li {
    padding: 3px 0;
    border-bottom: 1px solid #e9ecef;
  }

  .loading-section,
  .error-section {
    text-align: center;
    padding: 40px 20px;
    color: #6c757d;
  }

  .error-section {
    background: #f8d7da;
    color: #721c24;
    margin: 20px;
    border-radius: 8px;
  }

  /* Loading spinner */
  .loading-spinner {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    z-index: 1001;
    background: white;
    padding: 20px;
    border-radius: 8px;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
    display: none;
  }

  .loading-spinner.active {
    display: block;
  }

  .spinner {
    border: 3px solid #f3f3f3;
    border-top: 3px solid #007bff;
    border-radius: 50%;
    width: 40px;
    height: 40px;
    animation: spin 1s linear infinite;
    margin: 0 auto 10px;
  }

  @keyframes spin {
    0% {
      transform: rotate(0deg);
    }

    100% {
      transform: rotate(360deg);
    }
  }

  /* Modern Leaflet Popup Styles */
  .leaflet-popup-content-wrapper {
    background: rgba(255, 255, 255, 0.98) !important;
    backdrop-filter: blur(10px) !important;
    border-radius: 12px !important;
    box-shadow: 0 8px 30px rgba(0, 0, 0, 0.15) !important;
    padding: 0 !important;
    border: 2px solid rgba(102, 126, 234, 0.2) !important;
  }

  .leaflet-popup-content {
    margin: 0 !important;
    font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif !important;
    font-size: 14px !important;
    line-height: 1.6 !important;
    min-width: 250px !important;
    max-width: 350px !important;
  }

  .leaflet-popup-content .popup-content {
    padding: 16px !important;
    color: #2c3e50 !important;
  }

  .leaflet-popup-content .popup-content strong {
    display: inline-block;
    min-width: 120px;
    color: #667eea !important;
    font-weight: 700 !important;
    font-size: 13px !important;
    margin-right: 8px;
    text-transform: uppercase;
    letter-spacing: 0.5px;
  }

  .leaflet-popup-content .popup-content>div {
    border-bottom: 1px solid rgba(226, 232, 240, 0.5);
  }

  .leaflet-container a.leaflet-popup-close-button {
    width: 36px !important;
  }

  .leaflet-popup-content .popup-content>div:last-child {
    border-bottom: none;
    padding-bottom: 0;
  }

  .leaflet-popup-content .popup-content>div:first-child {
    padding-top: 0;
  }

  .leaflet-popup-tip {
    background: rgba(255, 255, 255, 0.98) !important;
    backdrop-filter: blur(10px) !important;
    border: 2px solid rgba(102, 126, 234, 0.2) !important;
    border-top: none !important;
    border-left: none !important;
  }

  .leaflet-popup-close-button {
    color: #6c757d !important;
    font-size: 24px !important;
    font-weight: 700 !important;
    padding: 8px 12px !important;
    transition: all 0.2s ease !important;
  }

  .leaflet-popup-close-button:hover {
    color: #dc3545 !important;
    background: rgba(220, 53, 69, 0.1) !important;
    border-radius: 4px !important;
  }

  .popup-content {
    max-width: 280px;
    font-size: 12px;
    line-height: 1.4;
  }

  .popup-resource-header {
    background: linear-gradient(135deg, #007bff, #0056b3);
    color: white;
    padding: 8px 12px;
    margin: -8px -12px 8px -12px;
    border-radius: 4px 4px 0 0;
    font-weight: 600;
  }

  /* Se√ßili Katmanlar Paneli - Responsive */
  .selected-layers-panel {
    position: absolute;
    top: 15px;
    right: 15px;
    display: flex;
    flex-direction: column;
    gap: 8px;
    z-index: 0;
    pointer-events: auto;
    padding: 12px;
    max-height: calc(100vh - 100px);
    overflow-y: auto;
    background: rgba(255, 255, 255, 0.95);
    border-radius: 12px;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
    width: auto;
    min-width: 280px;
    max-width: calc(100vw - 400px);
  }

  @media (max-width: 768px) {
    .selected-layers-panel {
      min-width: 240px;
      max-width: calc(100vw - 24px);
      right: 8px;
      top: 60px;
    }
  }

  .sel-chip {
    pointer-events: auto;
    display: grid;
    grid-template-columns: 16px auto auto;
    align-items: center;
    gap: 8px;
    background: rgba(255, 255, 255, 0.98);
    border: 1px solid #e5e7eb;
    border-radius: 12px;
    padding: 8px 10px;
    box-shadow: 0 2px 6px rgba(0, 0, 0, .08);
    backdrop-filter: saturate(1.1) blur(4px);
    width: fit-content;
  }

  .sel-dot {
    width: 12px;
    height: 12px;
    border-radius: 50%;
    border: 2px solid #fff;
    box-shadow: 0 0 0 1px rgba(0, 0, 0, .1);
  }

  .sel-name {
    font-size: 13px;
    font-weight: 600;
    color: #223;
    padding-right: 8px;
  }

  .sel-actions {
    display: flex;
    gap: 6px;
  }

  .sel-btn {
    border: 1px solid #e5e7eb;
    background: #fff;
    border-radius: 8px;
    padding: 5px 7px;
    cursor: pointer;
    font-size: 12px;
    line-height: 1;
    color: #374151;
    transition: all 0.2s;
  }

  .sel-btn:hover {
    background: #f3f4f6;
    transform: scale(1.05);
  }

  .sel-btn.danger:hover {
    background: #fee2e2;
    border-color: #fecaca;
  }

  .sel-btn.active {
    border-color: #60a5fa;
    background: #e0f2fe;
  }

  /* WMS GetCapabilities iframe g√∂r√ºnt√ºleme d√ºzeltmesi */
  .ckanext-datapreview iframe {
    width: 100% !important;
    min-height: 600px !important;
    background: white !important;
    border: 1px solid #e9ecef !important;
    border-radius: 8px !important;
  }

  /* XML g√∂r√ºnt√ºleme i√ßin stil */
  .ckanext-datapreview {
    padding: 10px;
    background: #f8f9fa;
    border-radius: 8px;
  }

  .marker-cluster-small,
  .marker-cluster-medium,
  .marker-cluster-large {
    background: transparent !important;
  }

  .marker-cluster-small div,
  .marker-cluster-medium div,
  .marker-cluster-large div {
    background: transparent !important;
  }


  /* √ñzel cluster ikonumuz ‚Äì katman rengini sabit tutar */
  .cluster-icon {}

  .cluster-icon .cluster-dot {
    width: 32px;
    height: 32px;
    border-radius: 50%;
    background: var(--bg, #888);
    opacity: var(--opacity, 0.85);
    border: 2px solid #fff;
    box-shadow: 0 0 0 2px rgba(0, 0, 0, .15);
    position: relative;
  }

  .cluster-icon .cluster-dot>span {
    position: absolute;
    inset: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    color: #fff;
    font-weight: 700;
    font-size: 12px;
    text-shadow: 0 1px 2px rgba(0, 0, 0, .5);
  }

  /* Zoom limit warning animasyonlarƒ± */
  @keyframes slideDown {
    from {
      opacity: 0;
      transform: translateX(-50%) translateY(-20px);
    }

    to {
      opacity: 1;
      transform: translateX(-50%) translateY(0);
    }
  }

  @keyframes slideUp {
    from {
      opacity: 1;
      transform: translateX(-50%) translateY(0);
    }

    to {
      opacity: 0;
      transform: translateX(-50%) translateY(-20px);
    }
  }

  /* ==== MOBƒ∞L ==== */
  @media (max-width: 900px) {

    html,
    body {
      overflow: auto !important;
      height: auto !important;
    }

    #content {
      overflow: visible !important;
    }


    .page-container {
      position: static !important;
      height: auto !important;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
    }


    .sidebar-filter {
      width: 100% !important;
      border-right: 0;
      border-bottom: 1px solid #e9ecef;
    }

    .panel-header,
    .filter-section,
    .search-section {
      display: block !important;
      flex-shrink: 0;
    }

    .panel-header {
      padding: 0 16px;
    }

    .filter-section {
      padding: 10px 12px;
      border-bottom: 1px solid #e9ecef;
    }

    .filter-label {
      font-size: 10px;
      margin-bottom: 6px;
    }

    .filter-row {
      gap: 8px;
      margin-bottom: 8px;
    }

    .filter-select {
      width: 100%;
      min-height: 36px;
      font-size: 13px;
    }


    .search-section {
      padding: 8px 12px;
      border-bottom: 1px solid #e9ecef;
    }

    .search-input {
      width: 100%;
      min-height: 36px;
      font-size: 13px;
    }


    .layers-panel {
      max-height: 48vh;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }

    .layers-content {
      flex: 1;
      min-height: 0;
      overflow-y: auto;
      -webkit-overflow-scrolling: touch;
      padding-bottom: 12px;
    }


    .resources-container {
      max-height: none;
    }

    .resource-item {
      padding: 10px 12px;
    }

    .main-container {
      height: calc(100vh - 48vh);
      position: relative !important;
      overflow: hidden;
    }

    #map {
      position: absolute;
      inset: 0;
    }

    .basemap-control {
      top: 10px;
      left: 10px;
    }

    .layer-switcher-control {
      top: 10px;
      right: 10px;
      max-width: 92vw;
    }

    .selected-layers-panel {
      top: 60px;
      right: 10px;
      max-width: 80px;
    }

    .sel-name {
      font-size: 8px;
    }


  }

  @media (max-width: 600px) {
    .layers-panel {
      max-height: 52vh;
    }

    .main-container {
      height: calc(100vh - 52vh);
    }

    .filter-row {
      grid-template-columns: 1fr;
      gap: 6px;
    }

    .filter-select,
    .search-input {
      min-height: 34px;
      font-size: 12px;
    }
  }

  .leaflet-popup-content-wrapper {
    border-radius: 12px;
    box-shadow: 0 10px 30px rgba(0, 0, 0, .12);
  }

  .leaflet-popup-content {
    margin: 12px 14px;
    /* Leaflet default‚Äôtan biraz dar */
  }

  /* ƒ∞√ß scroll istiyorsan max-height ver */
  .leaflet-popup-content .popup-compact {
    max-height: 380px;
    overflow-y: auto;
  }

  /* ƒ∞ki kolonlu ‚Äútablo‚Äù d√ºzeni */
  .popup-compact .popup-table {
    width: 100%;
    display: grid;
    grid-auto-rows: minmax(18px, auto);
    grid-row-gap: 8px;
  }

  .popup-compact .popup-row {
    display: grid;
    grid-template-columns: 90px 1fr;
    /* solda etiket, saƒüda deƒüer */
    align-items: start;
    padding: 8px 6px;
    border-bottom: 1px solid rgba(226, 232, 240, .7);
  }

  .popup-compact .popup-row:last-child {
    border-bottom: 0;
  }

  .popup-compact .popup-label {
    font-size: 12px;
    font-weight: 700;
    color: #5b75ea;
    /* mor-gri arasƒ± */
    letter-spacing: .3px;
    text-transform: uppercase;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }

  .popup-compact .popup-value {
    font-size: 13px;
    color: #1f2937;
    /* koyu gri */
    line-height: 1.35;
    overflow-wrap: anywhere;
  }

  /* Uzun metinler i√ßin ‚ÄúDaha fazla / Daha az‚Äù */
  .popup-compact .collapsible {
    position: relative;
    max-height: 78px;
    /* ~3-4 satƒ±r */
    overflow: hidden;
    transition: max-height .25s ease;
  }

  .popup-compact .collapsible.expanded {
    max-height: 600px;
  }

  .popup-compact .collapsible:not(.expanded)::after {
    content: "";
    position: absolute;
    left: 0;
    right: 0;
    bottom: 0;
    height: 28px;
    background: linear-gradient(to bottom, rgba(255, 255, 255, 0), rgba(255, 255, 255, .96));
  }

  .popup-compact .toggle-more {
    display: inline-block;
    margin-top: 6px;
    font-size: 12px;
    padding: 6px 10px;
    line-height: 1;
    border: 1px solid #e5e7eb;
    border-radius: 8px;
    background: #fff;
    color: #374151;
    cursor: pointer;
  }

  .popup-compact .toggle-more:hover {
    background: #f3f4f6;
  }



  .legend-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 12px;
    cursor: pointer;
    user-select: none;
  }

  .legend-title {
    font-size: 14px;
    font-weight: 700;
    color: #2c3e50;
    display: flex;
    align-items: center;
    gap: 6px;
  }

  .legend-toggle {
    background: none;
    border: none;
    font-size: 16px;
    color: #6c757d;
    cursor: pointer;
    padding: 0;
    width: 20px;
    height: 20px;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: transform 0.3s ease;
  }



  .legend-content {
    overflow-y: auto;
    max-height: 320px;
  }



  .legend-item {
    display: flex;
    align-items: center;
    gap: 10px;
    padding: 8px 0;
    border-bottom: 1px solid #f0f0f0;
    transition: background 0.2s ease;
  }

  .legend-item:last-child {
    border-bottom: none;
  }

  .legend-item:hover {
    background: #f8f9fa;
    padding-left: 4px;
    margin-left: -4px;
    border-radius: 6px;
  }

  .legend-color {
    width: 16px;
    height: 16px;
    border-radius: 50%;
    border: 2px solid white;
    box-shadow: 0 0 0 1px rgba(0, 0, 0, 0.1);
    flex-shrink: 0;
  }

  .legend-name {
    font-size: 12px;
    color: #495057;
    flex: 1;
    overflow-wrap: break-word;
    word-wrap: break-word;
    line-height: 1.4;
  }

  .legend-empty {
    text-align: center;
    padding: 20px 10px;
    color: #6c757d;
    font-size: 12px;
  }

  .legend-empty-icon {
    font-size: 32px;
    margin-bottom: 8px;
    opacity: 0.5;
  }

  /* Custom Legend Box (Sol Alt) */
/* Custom Legend Box (Sol Alt) */
  .custom-legend-box {
    position: fixed;  /* Map container'a g√∂re konumlanƒ±r */
    /* DEƒûƒ∞≈ûƒ∞KLƒ∞K: !important kaldƒ±rƒ±ldƒ± */
    bottom: auto;  /* Alt kenardan 20px yukarƒ±da */
    right: auto;   /* Saƒü kenardan 20px i√ßeride */
    background: white;
    border-radius: 12px;
    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
    padding: 16px;
    height: 150px;  /* Dinamik y√ºkseklik i√ßin auto olarak ayarlandƒ± */
    min-height:150px;
    min-width:150px;
    width: 150px;
    z-index: 400;  /* Leaflet kontrollerinin √ºzerinde */
    overflow-y: auto;
    overflow-x: hidden;
    display: none;
    flex-direction: column;
    transition: opacity 0.3s ease, transform 0.3s ease;
    cursor: move;  /* S√ºr√ºkleme g√∂stergesi */
  }

  /* Manuel resize yapƒ±ldƒ±ƒüƒ±nda bu class eklenecek */
  .custom-legend-box.manually-resized {
    height: var(--manual-height) !important;  /* Manuel y√ºkseklik deƒüi≈ükeni */
  }
  /* S√ºr√ºkleme sƒ±rasƒ±nda g√∂r√ºn√ºm */
  .custom-legend-box.dragging {
    opacity: 0.9;
    cursor: grabbing;
    transition: none;
    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.25);
  }

  /* Boyutlandƒ±rma sƒ±rasƒ±nda g√∂r√ºn√ºm */
  .custom-legend-box.resizing {
    opacity: 0.95;
    transition: none !important;
    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.25);
    user-select: none;
  }

  /* Resize sƒ±rasƒ±nda smooth animasyon i√ßin t√ºm transition'larƒ± kaldƒ±r */
  .custom-legend-box.resizing * {
    transition: none !important;
  }

  /* Resize handles - 4 taraftan ve 4 k√∂≈üeden */
  .custom-legend-resize-handle {
    position: absolute;
    background: transparent;
    z-index: 10;
  }

  /* Kenar handles - √ºst, saƒü, alt, sol */
  .custom-legend-resize-handle.top {
    top: 0;
    left: 0;
    right: 0;
    height: 6px;
    cursor: ns-resize;
  }

  .custom-legend-resize-handle.right {
    top: 0;
    right: 0;
    bottom: 0;
    width: 6px;
    cursor: ew-resize;
  }

  .custom-legend-resize-handle.bottom {
    bottom: 0;
    left: 0;
    right: 0;
    height: 6px;
    cursor: ns-resize;
  }

  .custom-legend-resize-handle.left {
    top: 0;
    left: 0;
    bottom: 0;
    width: 6px;
    cursor: ew-resize;
  }

  /* K√∂≈üe handles - daha b√ºy√ºk hit area */
  .custom-legend-resize-handle.top-left {
    top: 0;
    left: 0;
    width: 12px;
    height: 12px;
    cursor: nwse-resize;
  }

  .custom-legend-resize-handle.top-right {
    top: 0;
    right: 0;
    width: 12px;
    height: 12px;
    cursor: nesw-resize;
  }

  .custom-legend-resize-handle.bottom-left {
    bottom: 0;
    left: 0;
    width: 12px;
    height: 12px;
    cursor: nesw-resize;
  }

  .custom-legend-resize-handle.bottom-right {
    bottom: 0;
    right: 0;
    width: 24px;
    height: 24px;
    cursor: nwse-resize;
  }

  /* G√∂rsel g√∂sterge - sadece saƒü alt k√∂≈üede */
  .custom-legend-resize-handle.bottom-right::before {
    content: '';
    position: absolute;
    bottom: 8px;
    right: 4px;
    width: 3px;
    height: 3px;
    border-right: 2px solid #6c757d;
    border-bottom: 2px solid #6c757d;
    opacity: 0.4;
    transition: opacity 0.2s;
  }

  .custom-legend-resize-handle.bottom-right::after {
    content: '';
    position: absolute;
    bottom: 4px;
    right: 8px;
    width: 3px;
    height: 3px;
    border-right: 2px solid #6c757d;
    border-bottom: 2px solid #6c757d;
    opacity: 0.4;
    transition: opacity 0.2s;
  }

  .custom-legend-resize-handle.bottom-right:hover::before,
  .custom-legend-resize-handle.bottom-right:hover::after {
    opacity: 0.8;
  }

  .custom-legend-box.active {
    display: flex;
  }

  .custom-legend-box.collapsed {
    max-height: 52px;
    padding: 14px 16px;
  }

  .custom-legend-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 14px;
    cursor: move;  /* S√ºr√ºkleme g√∂stergesi */
    user-select: none;
    padding: 4px;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    color: white;
    border-radius: 8px;
    margin: -16px -16px 14px -16px;  /* Tam geni≈ülik */
    padding: 12px 16px;
  }

  .custom-legend-header:hover {
    background: linear-gradient(135deg, #764ba2 0%, #667eea 100%);
  }

  .custom-legend-box.collapsed .custom-legend-header {
    margin-bottom: 0;
  }

  .custom-legend-header-title {
    font-size: 15px;
    font-weight: 700;
    color: white;  /* Beyaz yapƒ±ldƒ± */
    display: flex;
    align-items: center;
    gap: 8px;
  }

  .custom-legend-header-toggle {
    background: rgba(255, 255, 255, 0.2);
    border: 1px solid rgba(255, 255, 255, 0.3);
    border-radius: 4px;
    font-size: 16px;
    color: white;  /* Beyaz yapƒ±ldƒ± */
    cursor: pointer;
    padding: 0;
    width: 24px;
    height: 24px;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: transform 0.3s ease, background 0.2s ease;
  }

  .custom-legend-header-toggle:hover {
    background: rgba(255, 255, 255, 0.3);
  }

  .custom-legend-box.collapsed .custom-legend-header-toggle {
    transform: rotate(180deg);
  }

  .custom-legend-box.collapsed .custom-legend-entries {
    display: none;
  }

  .custom-legend-entries {
    overflow-y: auto;
    max-height: 340px;
    display: flex;
    flex-direction: column;
    gap: 10px;
  }

  .custom-legend-entry {
    display: flex;
    align-items: center;
    gap: 12px;
    padding: 10px;
    border-radius: 8px;
    background: #f8f9fa;
    transition: all 0.2s ease;
  }

  .custom-legend-entry:hover {
    background: #e9ecef;
    transform: translateX(2px);
  }

  .custom-legend-entry-color {
    width: 28px;
    height: 28px;
    border-radius: 6px;
    border: 2px solid white;
    box-shadow: 0 2px 6px rgba(0, 0, 0, 0.15);
    flex-shrink: 0;
  }

  .custom-legend-entry-description {
    font-size: 13px;
    color: #495057;
    flex: 1;
    font-weight: 500;
    line-height: 1.4;
  }

  .custom-legend-empty {
    text-align: center;
    padding: 30px 10px;
    color: #6c757d;
    font-size: 12px;
  }

  .custom-legend-empty-icon {
    font-size: 48px;
    margin-bottom: 10px;
    opacity: 0.4;
  }

  /* Varsayƒ±lan: toggle butonu gizli (masa√ºst√º) */
  .mobile-filter-toggle {
    display: none;
  }

  /* Masa√ºst√º g√∂r√ºn√ºrl√ºƒü√º kontrol√º i√ßin yardƒ±mcƒ± sƒ±nƒ±f */
  .desktop-only {
    display: block;
  }

  /* Dropdown g√∂vdesi (kapalƒ±yken) */
  .filters-body {
    transition: height .25s ease, opacity .2s ease;
  }

  /* MOBƒ∞L: toggle butonu g√∂r√ºn√ºr, ba≈ülƒ±k gizlenir, g√∂vde varsayƒ±lan kapalƒ± */
  @media (max-width: 900px) {
    .mobile-filter-toggle {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
      width: 100%;
      font-size: 14px;
      font-weight: 600;
      border: 1px solid #e5e7eb;
      background: #fff;
      border-radius: 8px;
      padding: 10px 12px;
      cursor: pointer;
    }

    .filter-section {
      /* A√ßƒ±k/kapalƒ± durumunu sƒ±nƒ±fla y√∂neteceƒüiz */
    }

    .filter-section .desktop-only {
      display: none;
    }

    /* Kapalƒ± durum (default): g√∂vde gizli */
    .filter-section:not(.open) .filters-body {
      display: none;
      opacity: 0;
    }

    /* A√ßƒ±k durum: g√∂vde a√ßƒ±k */
    .filter-section.open .filters-body {
      display: block;
      opacity: 1;
      margin-top: 8px;
    }

    /* K√º√ß√ºk ok i≈üareti d√∂nd√ºrme */
    .filter-section.open .mobile-filter-toggle .chev {
      transform: rotate(180deg);
    }
  }
</style>

<div class="page-container">
  <!-- SOL: Sabit katman paneli -->
  <div class="sidebar-filter">
    <div class="layers-panel" id="layersPanel">
      <div class="panel-header">
        <div class="stats-grid">
          <div class="stat-item"><span class="stat-number" id="totalSpatialResources">-</span>
            <div class="stat-label">Veri Seti</div>
          </div>
          <div class="stat-item"><span class="stat-number" id="totalSpatialPackages">-</span>
            <div class="stat-label">Veri K√ºmesi</div>
          </div>
          <div class="stat-item"><span class="stat-number" id="activeLayers">-</span>
            <div class="stat-label">Aktif Katman</div>
          </div>
          <div class="stat-item"><span class="stat-number" id="totalFormats">-</span>
            <div class="stat-label">Veri Formatƒ±</div>
          </div>
        </div>
      </div>

      <!-- Filtreleme alanƒ± -->
      <div class="filter-section" id="filterSection">
        <!-- YENƒ∞: Mobil toggle butonu -->
        <button class="mobile-filter-toggle" id="mobileFilterToggle" type="button" aria-expanded="false"
          aria-controls="filtersBody">
          <span>üîé Filtreler</span>
          <span class="chev" aria-hidden="true">‚ñº</span>
        </button>

        <!-- ƒ∞STEƒûE BAƒûLI: Masa√ºst√º ba≈ülƒ±k (mobilde gizlenecek) -->
        <div class="filter-label desktop-only">Filtreler</div>

        <!-- YENƒ∞: Filtrelerin g√∂vdesi -->
        <div class="filters-body" id="filtersBody">
          <div class="filter-row">
            <select class="filter-select" id="organizationFilter">
              <option value="">T√ºm Veri Payda≈ülarƒ±</option>
            </select>
          </div>
          <div class="filter-row">
            <select class="filter-select" id="formatFilter">
              <option value="">T√ºm Formatlar</option>
            </select>
          </div>
          <div class="filter-row">
            <select class="filter-select" id="themeFilter">
              <option value="">T√ºm Temalar</option>
            </select>
          </div>
          <div class="filter-row">
            <select class="filter-select" id="categoryFilter">
              <option value="">T√ºm Kategoriler</option>
            </select>
          </div>
        </div>
      </div>

      <div class="search-section">
        <input type="search" class="search-input" id="layerSearch" placeholder="Veri seti arayƒ±n...">
      </div>

      <div class="layers-content" id="spatialLayersContainer">
        <div class="loading-section">Mekansal katmanlar y√ºkleniyor...</div>
      </div>
    </div>
  </div>

  <!-- SAƒû: Harita -->
  <div class="main-container">
    <!-- Harita taban se√ßici -->
    <div class="basemap-control">
      <button class="basemap-button active" data-basemap="sokak">üó∫Ô∏è Sokak</button>
      <button class="basemap-button" data-basemap="uydu">üõ∞Ô∏è Uydu</button>
      <button class="basemap-button" data-basemap="arazi">‚õ∞Ô∏è Arazi</button>
      <button class="basemap-button" data-basemap="sade">üìç Sade</button>
    </div>

    <!-- Layer Switcher Control -->
    <div class="layer-switcher-control" id="layerSwitcher" style="display: none;">
      <div class="layer-switcher-header">
        <span>üóÇÔ∏è Katman Kontrol√º</span>
        <button class="layer-switcher-toggle" onclick="spatialMapManager.toggleLayerSwitcher()">‚ñº</button>
      </div>
      <div class="layer-switcher-content" id="layerSwitcherContent">
        <!-- Dinamik olarak doldurulacak -->
      </div>
    </div>

    <div id="map"></div>

    <!-- Map Legend -->


    <!-- Custom Legend Box (Sol Alt) -->
    <div class="custom-legend-box" id="customLegendBox" >
      <div class="custom-legend-header">
        <div class="custom-legend-header-title">
          <span>üìä</span>
          <span>LEJANT</span>
        </div>
        <button class="custom-legend-header-toggle" onclick="spatialMapManager.toggleCustomLegend(); event.stopPropagation();">‚ñº</button>
      </div>
      <div class="custom-legend-entries" id="customLegendEntries">
        <div class="custom-legend-empty">
          <div class="custom-legend-empty-icon">üìù</div>
          <div>Aktif kaynaklar i√ßin lejant bilgisi yok</div>
        </div>
      </div>
      <!-- Resize handles - 4 kenar + 4 k√∂≈üe -->
      <div class="custom-legend-resize-handle top" data-direction="top"></div>
      <div class="custom-legend-resize-handle right" data-direction="right"></div>
      <div class="custom-legend-resize-handle bottom" data-direction="bottom"></div>
      <div class="custom-legend-resize-handle left" data-direction="left"></div>
      <div class="custom-legend-resize-handle top-left" data-direction="top-left"></div>
      <div class="custom-legend-resize-handle top-right" data-direction="top-right"></div>
      <div class="custom-legend-resize-handle bottom-left" data-direction="bottom-left"></div>
      <div class="custom-legend-resize-handle bottom-right" data-direction="bottom-right"></div>
    </div>

    <!-- Loading spinner -->
    <div class="loading-spinner" id="loadingSpinner">
      <div class="spinner"></div>
      <div style="text-align: center; color: #495057;">Veri y√ºkleniyor...</div>
    </div>

    <!-- Se√ßili katmanlar paneli -->
    <div class="selected-layers-panel" id="selectedLayersPanel" style="display: none;"></div>
  </div>

  <!-- Related Data Modal (ƒ∞li≈ükili Veriler Popup'ƒ±) -->
  <div id="relatedDataModal"
    style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.7); z-index: 10000; align-items: center; justify-content: center;">
    <div onclick="event.stopPropagation()"
      style="background: white; border-radius: 12px; max-width: 800px; max-height: 80vh; width: 90%; display: flex; flex-direction: column; box-shadow: 0 10px 40px rgba(0,0,0,0.4); margin: auto; margin-top: 5vh;">
      <div
        style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 20px; border-radius: 12px 12px 0 0; display: flex; justify-content: space-between; align-items: center;">
        <h3 style="margin: 0; font-size: 18px;">üìä ƒ∞li≈ükili Veri Setleri</h3>
        <button onclick="spatialMapManager.closeRelatedDataModal()"
          style="background: none; border: none; color: white; font-size: 28px; cursor: pointer; line-height: 1;">&times;</button>
      </div>
      <div id="relatedDataContent" style="padding: 20px; overflow-y: auto; flex: 1;">
        <div style="text-align: center; padding: 40px; color: #6c757d;">
          <div style="font-size: 48px; margin-bottom: 16px;">‚è≥</div>
          <p>Y√ºkleniyor...</p>
        </div>
      </div>
    </div>
  </div>
</div>

<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

<link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.css" />
<link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.Default.css" />
<script src="https://unpkg.com/leaflet.markercluster@1.5.3/dist/leaflet.markercluster.js"></script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet-omnivore/0.3.4/leaflet-omnivore.min.js"></script>
<script src="https://unpkg.com/shpjs@3.6.0/dist/shp.min.js"></script>

<script src="https://unpkg.com/georaster@1.5.6/dist/georaster.browser.bundle.min.js"></script>
<script src="https://unpkg.com/georaster-layer-for-leaflet@3.10.0/dist/georaster-layer-for-leaflet.min.js"></script>
<script src="https://unpkg.com/geotiff@2.0.7/dist/geotiff.bundle.min.js"></script>

<script>
  console.log('Modern Mekansal G√∂r√ºnt√ºleme Sistemi v4.1 - ƒ∞yile≈ütirilmi≈ü Lejant Pozisyonlamasƒ±');

  class SpatialMapManager {
    constructor() {
      this.map = null;
      this.spatialData = [];
      this.packageGroups = {};
      this.resourceLayers = {};
      this.activeResources = new Set();

      // Cache mekanizmasƒ±
      this.dataCache = new Map();
      this.pendingRequests = new Map();

      // Harita tabanlarƒ±
      this.baseMaps = {};
      this.currentBaseMap = 'sokak';

      // Default collapsed packages
      this.collapsedPackages = new Set();
      this.layerPanes = {};

      // Focus durumu
      this.focusMode = false;
      this.focusedResourceId = null;

      // Filtreler
      this.selectedTheme = '';
      this.selectedCategory = '';
      this.selectedOrganization = '';
      this.selectedFormat = '';
      this.searchTerm = '';

      // Kullanƒ±cƒ± durumu
      this.isLoggedIn = false;

      // Tema haritasƒ±
      this.themeMap = {};

      // WMS layer bilgileri
      this.wmsLayers = {};
      this.wmsLayerStates = {};

      // Performans i√ßin throttling
      this.renderThrottle = null;
      this.loadingQueue = [];
      this.isLoadingResource = false;

      // Layer Switcher durumu
      this.layerSwitcherExpanded = false;

      this.init();
    }

    async init() {
      try {
        this.initMap();
        await this.loadSpatialData();
        this.setupFilters();
        this.setupEventListeners();
        this.renderLayers();
        this.updateStats();
        this.initDraggableLegend();  // S√ºr√ºkleme fonksiyonunu ba≈ülat
        this.initResizableLegend();  // Boyutlandƒ±rma fonksiyonunu ba≈ülat
        await this.loadAllCustomLegends();  // Lejantƒ± g√∂ster
      } catch (error) {
        console.error('Initialization hatasƒ±:', error);
        this.showError('Mekansal veriler y√ºklenirken hata olu≈ütu: ' + error.message);
      }
    }


    initMap() {
      this.map = L.map('map', {
        center: [38.4237, 27.1428],
        zoom: 10,
        zoomControl: true,
        scrollWheelZoom: true,
        preferCanvas: true // Performans i√ßin canvas renderer kullan
      });

      // Farklƒ± harita tabanlarƒ±
      this.baseMaps = {
        sokak: L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
          maxZoom: 19,
          attribution: '¬© OpenStreetMap'
        }),
        uydu: L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
          maxZoom: 17, // Uydu i√ßin maksimum zoom limiti
          attribution: '¬© Esri'
        }),
        arazi: L.tileLayer('https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png', {
          maxZoom: 17,
          attribution: '¬© OpenTopoMap'
        }),
        sade: L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png', {
          maxZoom: 19,
          attribution: '¬© CARTO'
        })
      };

      // Default haritayƒ± ekle
      this.baseMaps[this.currentBaseMap].addTo(this.map);

      // Zoom limit kontrol√º i√ßin event listener
      this.map.on('zoomend', () => {
        this.checkZoomLimit();
      });

      // Basemap deƒüi≈ütirme butonlarƒ±
      document.querySelectorAll('.basemap-button').forEach(btn => {
        btn.addEventListener('click', (e) => {
          const basemap = e.target.dataset.basemap;
          this.switchBasemap(basemap);
        });
      });
    }

    switchBasemap(basemap) {
      if (basemap === this.currentBaseMap) return;

      this.map.removeLayer(this.baseMaps[this.currentBaseMap]);
      this.baseMaps[basemap].addTo(this.map);
      this.currentBaseMap = basemap;

      document.querySelectorAll('.basemap-button').forEach(btn => {
        btn.classList.toggle('active', btn.dataset.basemap === basemap);
      });

      // Uydu g√∂r√ºn√ºm√ºne ge√ßildiƒüinde zoom kontrol√º
      this.checkZoomLimit();
    }

    checkZoomLimit() {
      // Sadece uydu g√∂r√ºn√ºm√º i√ßin zoom limiti kontrol√º
      if (this.currentBaseMap === 'uydu') {
        const currentZoom = this.map.getZoom();
        const maxZoom = this.baseMaps.uydu.options.maxZoom;

        if (currentZoom >= maxZoom) {
          // Uyarƒ± mesajƒ± g√∂ster
          this.showZoomLimitWarning();
        }
      }
    }

    showZoomLimitWarning() {
      // Eƒüer zaten varsa g√∂sterme
      if (document.getElementById('zoomLimitWarning')) return;

      const warning = document.createElement('div');
      warning.id = 'zoomLimitWarning';
      warning.style.cssText = `
        position: absolute;
        top: 60px;
        left: 50%;
        transform: translateX(-50%);
        background: linear-gradient(135deg, #ff6b6b 0%, #ee5a24 100%);
        color: white;
        padding: 12px 20px;
        border-radius: 8px;
        box-shadow: 0 4px 12px rgba(0,0,0,0.2);
        z-index: 1001;
        font-size: 14px;
        font-weight: 600;
        display: flex;
        align-items: center;
        gap: 10px;
        animation: slideDown 0.3s ease;
      `;
      warning.innerHTML = `
        <span style="font-size: 20px;">‚ö†Ô∏è</span>
        <span>Uydu g√∂r√ºn√ºm√ºnde maksimum yakƒ±nla≈ütƒ±rma seviyesine ula≈ütƒ±nƒ±z.</span>
        <button onclick="this.parentElement.remove()" style="background: rgba(255,255,255,0.2); border: none; color: white; padding: 4px 8px; border-radius: 4px; cursor: pointer; margin-left: 10px;">‚úï</button>
      `;

      document.querySelector('.main-container').appendChild(warning);

      // 5 saniye sonra otomatik kaldƒ±r
      setTimeout(() => {
        if (warning.parentElement) {
          warning.style.animation = 'slideUp 0.3s ease';
          setTimeout(() => warning.remove(), 300);
        }
      }, 5000);
    }

    toggleLayerSwitcher() {
      this.layerSwitcherExpanded = !this.layerSwitcherExpanded;
      const content = document.getElementById('layerSwitcherContent');
      const toggle = document.querySelector('.layer-switcher-toggle');

      if (this.layerSwitcherExpanded) {
        content.classList.add('expanded');
        toggle.textContent = '‚ñ≤';
      } else {
        content.classList.remove('expanded');
        toggle.textContent = '‚ñº';
      }
    }

    renderLayerSwitcherContent() {
      const content = document.getElementById('layerSwitcherContent');
      let html = '';

      console.log('WMS Layers:', this.wmsLayers);
      console.log('Active Resources:', this.activeResources);

      // T√ºm WMS layer'larƒ± g√∂ster (activeResources kontrol√º olmadan)
      for (const [resourceId, layers] of Object.entries(this.wmsLayers)) {
        const resource = this.resourceLayers[resourceId]?.resource;
        if (!resource) continue;

        html += `
          <div class="wms-layer-info">
            <strong>${resource.resource_name}</strong>
            <div class="wms-layer-list">
        `;

        // Her layer i√ßin checkbox ve opacity slider ekle
        layers.forEach((layer, index) => {
          const layerId = `${resourceId}_${index}`;
          const isChecked = this.wmsLayerStates[layerId] !== false;
          const opacity = this.wmsLayerStates[layerId + '_opacity'] || 100;

          html += `
            <div class="layer-switcher-item">
              <input type="checkbox" 
                     id="layer_${layerId}" 
                     class="layer-switcher-checkbox"
                     ${isChecked ? 'checked' : ''}
                     onchange="spatialMapManager.toggleWMSLayer('${resourceId}', '${layer.name}', ${index})">
              <label for="layer_${layerId}" class="layer-switcher-label">
                ${layer.title || layer.name}
              </label>
            </div>
            <div class="layer-switcher-opacity">
              <span style="font-size: 11px;">üìä</span>
              <input type="range" 
                     class="opacity-slider" 
                     min="0" max="100" 
                     value="${opacity}"
                     oninput="spatialMapManager.updateWMSOpacity('${resourceId}', '${layer.name}', this.value, ${index})">
              <span class="opacity-value">${opacity}%</span>
            </div>
          `;
        });

        html += '</div></div>';
      }

      if (html === '') {
        html = '<div style="padding: 10px; text-align: center; color: #6c757d;">Aktif WMS katmanƒ± yok</div>';
      }

      content.innerHTML = html;
    }

    toggleWMSLayer(resourceId, layerName, layerIndex) {
      const layerId = `${resourceId}_${layerIndex}`;
      const checkbox = document.getElementById(`layer_${layerId}`);
      const isChecked = checkbox.checked;

      // State'i g√ºncelle
      this.wmsLayerStates[layerId] = isChecked;

      // WMS layer'ƒ± g√ºncelle
      const rl = this.resourceLayers[resourceId];
      if (rl && rl.layer) {
        if (rl.wmsLayerObjs && rl.wmsLayerObjs[layerName]) {
          const layer = rl.wmsLayerObjs[layerName];
          if (isChecked) {
            layer.addTo(this.map);
          } else {
            this.map.removeLayer(layer);
          }
        }
      }
    }

    updateWMSOpacity(resourceId, layerName, value, layerIndex) {
      const layerId = `${resourceId}_${layerIndex}`;
      const opacity = value / 100;

      // State'i g√ºncelle
      this.wmsLayerStates[layerId + '_opacity'] = value;

      // Opacity deƒüerini g√ºncelle
      const opacityValue = document.querySelector(`#layer_${layerId}`).parentElement.nextElementSibling.querySelector('.opacity-value');
      if (opacityValue) {
        opacityValue.textContent = value + '%';
      }

      // WMS layer opacity'sini g√ºncelle
      const rl = this.resourceLayers[resourceId];
      if (rl && rl.wmsLayerObjs && rl.wmsLayerObjs[layerName]) {
        rl.wmsLayerObjs[layerName].setOpacity(opacity);
      }
    }

    showLoading() {
      document.getElementById('loadingSpinner').classList.add('active');
    }

    hideLoading() {
      document.getElementById('loadingSpinner').classList.remove('active');
    }

    async loadSpatialData() {
      const cacheKey = 'spatial-resources';
      if (this.dataCache.has(cacheKey)) {
        const cachedData = this.dataCache.get(cacheKey);
        if (Date.now() - cachedData.timestamp < 300000) { // 5 dakika cache
          this.spatialData = cachedData.data;
          this.createPackageGroups();
          return;
        }
      }

      if (this.pendingRequests.has(cacheKey)) {
        await this.pendingRequests.get(cacheKey);
        return;
      }

      const promise = this.fetchSpatialData();
      this.pendingRequests.set(cacheKey, promise);

      try {
        const data = await promise;
        this.dataCache.set(cacheKey, { data, timestamp: Date.now() });
        this.spatialData = data;
        this.createPackageGroups();
      } finally {
        this.pendingRequests.delete(cacheKey);
      }
    }

    async fetchSpatialData() {
      const response = await fetch('/api/spatial-resources/list', {
        credentials: 'include',
        headers: {
          'Cache-Control': 'max-age=300'
        }
      });
      const data = await response.json();

      if (!data.success) throw new Error(data.error || 'Spatial resources API hatasƒ±');

      let resources = data.spatial_resources || [];

      // Giri≈ü yapmamƒ±≈ü kullanƒ±cƒ± i√ßin private paketleri filtrele
      if (!this.isLoggedIn) {
        const publicPackages = await this.getPublicPackages();
        resources = resources.filter(r => publicPackages.has(r.package_id));
      }

      // Tema ve kategori bilgilerini ekle
      const enrichedData = await this.enrichResourcesWithPackageInfo(resources);
      return enrichedData;
    }

    async getPublicPackages() {
      const publicPackages = new Set();
      try {
        const response = await fetch('/api/3/action/package_search?rows=1000', {
          credentials: 'include'
        });
        const data = await response.json();

        if (data.success && data.result && data.result.results) {
          data.result.results.forEach(pkg => {
            if (!pkg.private) {
              publicPackages.add(pkg.id);
            }
          });
        }
      } catch (error) {
        console.error('Public packages y√ºklenemedi:', error);
      }
      return publicPackages;
    }

    async loadThemes() {
      try {
        // T√ºm temalarƒ± √ßek
        const themeListResponse = await fetch('/api/3/action/theme_category_list', { credentials: 'include' });
        const themeListData = await themeListResponse.json();

        if (themeListData.success && themeListData.result) {
          // Her tema i√ßin dataset ili≈ükilerini √ßek
          const themePromises = themeListData.result.map(theme =>
            fetch(`/api/3/action/theme_category_show?slug=${theme.slug}`, { credentials: 'include' })
              .then(r => r.json())
              .then(data => {
                if (data.success && data.result && data.result.datasets) {
                  return {
                    themeName: theme.name || theme.slug,
                    datasets: data.result.datasets
                  };
                }
                return null;
              })
              .catch(err => {
                console.warn(`Tema '${theme.slug}' y√ºklenemedi:`, err);
                return null;
              })
          );

          const themeResults = await Promise.all(themePromises);
          const tempMap = {};

          themeResults.forEach(result => {
            if (result) {
              result.datasets.forEach(dataset => {
                // Dataset ID'ye g√∂re tema adƒ±nƒ± kaydet
                tempMap[dataset.id] = result.themeName;
              });
            }
          });

          return tempMap;
        }
      } catch (error) {
        console.error("Tema listesi y√ºklenirken hata:", error);
      }
      return {};
    }

    async enrichResourcesWithPackageInfo(resources) {
      // √ñnce temalarƒ± y√ºkle
      this.themeMap = await this.loadThemes();

      const packageIds = [...new Set(resources.map(r => r.package_id))];

      // Package bilgilerini paralel olarak √ßek
      const packageInfos = await Promise.all(
        packageIds.map(async (pid) => {
          try {
            const response = await fetch(`/api/3/action/package_show?id=${pid}`, {
              credentials: 'include'
            });
            const data = await response.json();
            return data.success ? data.result : null;
          } catch {
            return null;
          }
        })
      );

      const packageMap = new Map();
      packageInfos.forEach((pkg, index) => {
        if (pkg) {
          const packageId = packageIds[index];
          packageMap.set(packageId, {
            // Tema bilgisini theme map'ten al
            theme: this.themeMap[packageId] || null,
            groups: pkg.groups || [],
            tags: pkg.tags || [],
            private: pkg.private || false,
            organization_title: pkg.organization?.title || pkg.organization?.display_name || null
          });
        }
      });

      return resources.map(resource => {
        const pkgInfo = packageMap.get(resource.package_id) || {};
        return {
          ...resource,
          theme: pkgInfo.theme,
          groups: pkgInfo.groups,
          tags: pkgInfo.tags,
          private: pkgInfo.private,
          organization_title: pkgInfo.organization_title
        };
      });
    }

    createPackageGroups() {
      this.packageGroups = {};
      this.spatialData.forEach(resource => {
        const pid = resource.package_id;
        if (!this.packageGroups[pid]) {
          this.packageGroups[pid] = {
            id: pid,
            name: resource.package_title,
            package_name: resource.package_name,
            theme: resource.theme,
            groups: resource.groups,
            resources: [],
            private: resource.private
          };
        }
        this.packageGroups[pid].resources.push(resource);
        this.resourceLayers[resource.resource_id] = {
          resource,
          layer: L.layerGroup(),
          visible: false,
          loaded: false,
          _cluster: null,
          _vector: null,
          wmsLayerObjs: {} // WMS layer objelerini saklayacaƒüƒ±z
        };
      });

      // T√ºm paketleri ba≈ülangƒ±√ßta collapsed olarak i≈üaretle
      Object.keys(this.packageGroups).forEach(pid => {
        this.collapsedPackages.add(pid);
      });
    }

    setupFilters() {
      // Tema, kategori, organizasyon ve format listelerini olu≈ütur
      const themes = new Set(['']);
      const categories = new Set(['']);
      const organizations = new Set(['']);
      const formats = new Set(['']);

      this.spatialData.forEach(resource => {
        if (resource.theme) themes.add(resource.theme);
        if (resource.organization_title) organizations.add(resource.organization_title);
        if (resource.format) formats.add(resource.format.toUpperCase());
        resource.groups?.forEach(g => {
          const categoryName = g.display_name || g.name;
          if (categoryName) categories.add(categoryName);
        });
      });

      // Organization filter
      const orgSelect = document.getElementById('organizationFilter');
      orgSelect.innerHTML = '<option value="">T√ºm Veri Payda≈ülarƒ±</option>';
      [...organizations].filter(o => o).sort().forEach(org => {
        const option = document.createElement('option');
        option.value = org;
        option.textContent = org;
        orgSelect.appendChild(option);
      });

      // Format filter
      const formatSelect = document.getElementById('formatFilter');
      formatSelect.innerHTML = '<option value="">T√ºm Formatlar</option>';
      [...formats].filter(f => f).sort().forEach(format => {
        const option = document.createElement('option');
        option.value = format;
        option.textContent = format;
        formatSelect.appendChild(option);
      });

      // Theme filter
      const themeSelect = document.getElementById('themeFilter');
      themeSelect.innerHTML = '<option value="">T√ºm Temalar</option>';
      [...themes].filter(t => t).sort().forEach(theme => {
        const option = document.createElement('option');
        option.value = theme;
        option.textContent = theme;
        themeSelect.appendChild(option);
      });

      // Category filter
      const categorySelect = document.getElementById('categoryFilter');
      categorySelect.innerHTML = '<option value="">T√ºm Kategoriler</option>';
      [...categories].filter(c => c).sort().forEach(category => {
        const option = document.createElement('option');
        option.value = category;
        option.textContent = category;
        categorySelect.appendChild(option);
      });
    }

    filterPackages() {
      const filtered = {};

      Object.values(this.packageGroups).forEach(group => {
        let shouldShow = true;

        // Theme filter
        if (this.selectedTheme && group.theme !== this.selectedTheme) {
          shouldShow = false;
        }

        // Category filter
        if (this.selectedCategory) {
          const hasCategory = group.groups?.some(g =>
            (g.display_name || g.name) === this.selectedCategory
          );
          if (!hasCategory) shouldShow = false;
        }

        // Organization filter
        if (this.selectedOrganization) {
          const hasOrg = group.resources.some(r =>
            r.organization_title === this.selectedOrganization
          );
          if (!hasOrg) shouldShow = false;
        }

        // Format filter
        if (this.selectedFormat) {
          const hasFormat = group.resources.some(r =>
            (r.format || '').toUpperCase() === this.selectedFormat
          );
          if (!hasFormat) shouldShow = false;
        }

        // Search filter
        if (this.searchTerm) {
          const matchesSearch = group.resources.some(r =>
            r.package_title.toLowerCase().includes(this.searchTerm) ||
            r.resource_name.toLowerCase().includes(this.searchTerm) ||
            (r.format || '').toLowerCase().includes(this.searchTerm)
          );
          if (!matchesSearch) shouldShow = false;
        }

        if (shouldShow) {
          filtered[group.id] = group;
        }
      });

      return filtered;
    }

    createPaneForResource(resourceId, isRaster = false) {
      if (this.layerPanes[resourceId]) return this.layerPanes[resourceId];
      const paneName = `pane_${resourceId}`;
      const pane = this.map.createPane(paneName);
      // Base map: ~200, Raster: 300-400, Vector: 450-500
      pane.style.zIndex = isRaster ? 350 : 450;
      this.layerPanes[resourceId] = paneName;
      return paneName;
    }

    async toggleResource(resourceId, isVisible) {
      const rl = this.resourceLayers[resourceId];
      if (!rl) return;

      if (isVisible) {
        // Resource'u y√ºkleme kuyruƒüuna ekle
        this.loadingQueue.push({ resourceId, action: 'load' });
        this.processLoadingQueue();
      } else {
        // Kapatma i≈ülemi
        this.map.removeLayer(rl.layer);
        this.activeResources.delete(resourceId);
        rl.visible = false;

        // WMS layer bilgilerini temizle
        if (this.wmsLayers[resourceId]) {
          delete this.wmsLayers[resourceId];
          this.renderLayerSwitcherContent();

          // Eƒüer hi√ß WMS layer kalmadƒ±ysa Layer Switcher'ƒ± gizle
          if (Object.keys(this.wmsLayers).length === 0) {
            document.getElementById('layerSwitcher').style.display = 'none';
          }
        }

        if (this.focusedResourceId === resourceId) {
          this.focusMode = false;
          this.focusedResourceId = null;
        }

        this.updateResourceToggleState(resourceId, false);
        this.updateStats();
        this.updateEmphasis();
        this.renderSelectedLayersPanel();
        this.updateCustomLegendForActiveResources(); // Update custom legend
      }
    }

    async processLoadingQueue() {
      if (this.isLoadingResource || this.loadingQueue.length === 0) return;

      this.isLoadingResource = true;
      this.showLoading();

      while (this.loadingQueue.length > 0) {
        const { resourceId } = this.loadingQueue.shift();
        const rl = this.resourceLayers[resourceId];

        if (!rl.loaded) {
          await this.loadResourceData(resourceId);
        }

        if (rl.loaded) {
          rl.layer.addTo(this.map);
          this.activeResources.add(resourceId);
          rl.visible = true;

          const fmt = (rl.resource.format || '').toLowerCase();
          rl.layer.eachLayer(l => {
            (fmt === 'wms' || fmt === 'geotiff') ? l.bringToBack?.() : l.bringToFront?.();
          });
        }

        this.updateResourceToggleState(resourceId, true);
        this.updateCustomLegendForActiveResources(); // Update custom legend
        this.updateStats();
        this.fitMapToActiveLayers();
        this.updateEmphasis();
        this.renderSelectedLayersPanel();
      }

      this.isLoadingResource = false;
      this.hideLoading();
    }

    async loadResourceData(resourceId) {
      const rl = this.resourceLayers[resourceId];
      if (!rl || rl.loaded) return;

      try {
        const fmt = (rl.resource.format || '').toLowerCase();

        if (['wms', 'wfs', 'geotiff'].includes(fmt)) {
          await this.addLayerFromUrl(rl.resource.url, fmt, rl.layer, resourceId);
          rl.loaded = true;
          return;
        }

        const cacheKey = `resource-${resourceId}`;
        if (this.dataCache.has(cacheKey)) {
          const cachedData = this.dataCache.get(cacheKey);
          if (Date.now() - cachedData.timestamp < 600000) { // 10 dakika cache
            await this.processResourceData(cachedData.data, resourceId, cachedData.type);
            rl.loaded = true;
            return;
          }
        }

        const apiUrl = `/api/spatial-resources/${resourceId}/data`;
        const response = await fetch(apiUrl, { credentials: 'include' });

        if (!response.ok) throw response;
        const result = await response.json();

        if (!result.success) throw new Error(result.error || 'Bilinmeyen API hatasƒ±');

        this.dataCache.set(cacheKey, {
          data: result.data || result.url,
          type: result.type,
          timestamp: Date.now()
        });

        if (result.type === 'shp') {
          await this.processShpData(result.url, resourceId);
        } else if (result.type === 'api') {
          await this.processApiDataFrontend(result.url, resourceId);
        } else if (result.type === 'geojson_url') {
          await this.processGeoJsonFrontend(result.url, resourceId);
        } else {
          await this.addGeoJSONToLayer(result.data, rl.layer, resourceId);
          rl.loaded = true;
        }

      } catch (error) {
        console.error('[DEBUG] Resource data y√ºklenirken hata:', error);
        this.showResourceError(resourceId, error.message || 'Hata');
        this.updateResourceToggleState(resourceId, false);
        this.activeResources.delete(resourceId);
      }
    }

    async processResourceData(data, resourceId, type) {
      const rl = this.resourceLayers[resourceId];
      if (type === 'geojson' || !type) {
        await this.addGeoJSONToLayer(data, rl.layer, resourceId);
      }
    }

    async downloadResourceData(resourceId) {
      const rl = this.resourceLayers[resourceId];
      if (!rl) return;

      const resource = rl.resource;
      const format = (resource.format || '').toLowerCase();

      try {
        this.showLoading();

        // Edge case: EU Hydro River Network GeoTIFF i√ßin √∂zel indirme linki
        if (resourceId === '7acef04c-d0f5-461e-bd19-5940c4e7b520') {
          const downloadUrl = 'https://dataizmir.izka.org.tr/dataset/8fb7040e-304d-4785-a50a-bb86a341e8f3/resource/7acef04c-d0f5-461e-bd19-5940c4e7b520/download/eu-hydro-river-tetwork-database.tif';
          const a = document.createElement('a');
          a.href = downloadUrl;
          a.download = 'eu-hydro-river-network.tif';
          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);
          this.hideLoading();
          return;
        }

        // API veya diƒüer formatlar i√ßin
        const apiUrl = `/api/spatial-resources/${resourceId}/data`;
        const response = await fetch(apiUrl, { credentials: 'include' });

        if (!response.ok) {
          throw new Error('Veri alƒ±namadƒ±');
        }

        const result = await response.json();

        let dataToDownload;
        let fileName = resource.resource_name || 'data';
        let mimeType = 'application/json';

        // Format'a g√∂re dosya adƒ± ve mime type ayarla
        if (format === 'csv') {
          mimeType = 'text/csv';
          fileName += '.csv';
        } else if (format === 'geojson') {
          mimeType = 'application/geo+json';
          fileName += '.geojson';
        } else if (format === 'json' || format === 'api' || format === 'rest') {
          mimeType = 'application/json';
          fileName += '.json';
        } else if (format === 'xlsx' || format === 'xls') {
          // Excel dosyalarƒ± i√ßin doƒürudan URL'den indir
          if (resource.url) {
            const a = document.createElement('a');
            a.href = resource.url;
            a.download = fileName + (format === 'xlsx' ? '.xlsx' : '.xls');
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            this.hideLoading();
            return;
          }
        } else if (format === 'shp') {
          // SHP i√ßin doƒürudan ZIP URL'den indir
          if (result.url) {
            const a = document.createElement('a');
            a.href = result.url;
            a.download = fileName + '.zip';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            this.hideLoading();
            return;
          }
        } else {
          fileName += '.json';
        }

        // Veriyi hazƒ±rla
        if (result.data) {
          dataToDownload = JSON.stringify(result.data, null, 2);
        } else if (result.type === 'api' && result.url) {
          // API verisi i√ßin fetch et
          const apiResponse = await fetch(result.url);
          const apiData = await apiResponse.json();
          dataToDownload = JSON.stringify(apiData, null, 2);
        } else if (result.type === 'geojson_url' && result.url) {
          // GeoJSON URL'den fetch et
          const geoResponse = await fetch(result.url);
          const geoData = await geoResponse.json();
          dataToDownload = JSON.stringify(geoData, null, 2);
        } else {
          throw new Error('ƒ∞ndirilecek veri bulunamadƒ±');
        }

        // Blob olu≈ütur ve indir
        const blob = new Blob([dataToDownload], { type: mimeType });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = fileName;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);

        this.hideLoading();
      } catch (error) {
        console.error('ƒ∞ndirme hatasƒ±:', error);
        alert('Veri indirme sƒ±rasƒ±nda hata olu≈ütu: ' + error.message);
        this.hideLoading();
      }
    }

    async extractWMSLayersInfo(url) {
      try {
        // GetCapabilities isteƒüi yap
        const capabilitiesUrl = url.includes('?')
          ? `${url}&service=WMS&request=GetCapabilities&version=1.3.0`
          : `${url}?service=WMS&request=GetCapabilities&version=1.3.0`;

        console.log('GetCapabilities URL:', capabilitiesUrl);

        const response = await fetch(capabilitiesUrl);
        const text = await response.text();

        // XML'den layer bilgilerini √ßƒ±kar
        const parser = new DOMParser();
        const xmlDoc = parser.parseFromString(text, "text/xml");

        const layers = [];
        const layerElements = xmlDoc.getElementsByTagName("Layer");

        // TUCBS servisleri i√ßin √∂zel durum
        if (url.includes('tucbs') || url.includes('csb.gov.tr')) {
          // Root layer'ƒ± atla, sadece alt layer'larƒ± al
          // ƒ∞lk Layer genellikle root, onun altƒ±ndaki Layer'larƒ± al
          for (let i = 0; i < layerElements.length; i++) {
            const layer = layerElements[i];
            const nameEl = layer.getElementsByTagName("Name")[0];
            const titleEl = layer.getElementsByTagName("Title")[0];

            // Name'i olan ve queryable olan layer'larƒ± al
            if (nameEl && nameEl.textContent && layer.getAttribute('queryable') === '1') {
              // Parent layer olmadƒ±ƒüƒ±ndan emin ol (child layer kontrol√º)
              const hasChildLayers = layer.getElementsByTagName("Layer").length > 0;

              // Eƒüer child layer'ƒ± yoksa (yani kendisi leaf node ise) ekle
              if (!hasChildLayers) {
                layers.push({
                  name: nameEl.textContent,
                  title: titleEl ? titleEl.textContent : nameEl.textContent,
                  queryable: true
                });
              }
            }
          }
        } else {
          // Diƒüer WMS servisleri i√ßin normal i≈ülem
          for (let i = 1; i < layerElements.length; i++) {
            const layer = layerElements[i];
            const nameEl = layer.getElementsByTagName("Name")[0];
            const titleEl = layer.getElementsByTagName("Title")[0];

            if (nameEl && nameEl.textContent) {
              layers.push({
                name: nameEl.textContent,
                title: titleEl ? titleEl.textContent : nameEl.textContent,
                queryable: layer.getAttribute('queryable') === '1'
              });
            }
          }
        }

        console.log('Bulunan WMS Layers:', layers);
        return layers;
      } catch (error) {
        console.warn('WMS Layer bilgileri alƒ±namadƒ±:', error);
        return [];
      }
    }

    async addLayerFromUrl(url, format, layerGroup, resourceId) {
      layerGroup.clearLayers();
      const resource = this.resourceLayers[resourceId].resource;

      try {
        switch ((format || '').toLowerCase()) {
          case 'wms': {
            // √ñnce WMS layer bilgilerini al
            const layers = await this.extractWMSLayersInfo(url);

            console.log('WMS Layers bulundu:', layers);

            if (layers.length > 0) {
              // WMS layer bilgilerini sakla
              this.wmsLayers[resourceId] = layers;

              // T√ºm layer'larƒ± ekle
              const paneName = this.createPaneForResource(resourceId, true);
              const rl = this.resourceLayers[resourceId];

              // TUCBS i√ßin rastgele bir layer se√ß
              const isTucbs = url.includes('tucbs') || url.includes('csb.gov.tr');
              const randomIndex = isTucbs ? Math.floor(Math.random() * layers.length) : 0;

              // Layer'larƒ± olu≈ütur
              layers.forEach((layerInfo, index) => {
                const wmsLayer = L.tileLayer.wms(url, {
                  layers: layerInfo.name,
                  format: 'image/png',
                  transparent: true,
                  version: '1.3.0',
                  crs: L.CRS.EPSG3857,
                  uppercase: true,
                  attribution: `WMS: ${resource.resource_name} - ${layerInfo.title}`,
                  pane: paneName,
                  tileSize: 256,
                  opacity: 1.0,
                  // TUCBS i√ßin √∂zel parametreler
                  ...(isTucbs ? {
                    srs: 'EPSG:3857',
                    bbox: '{bbox-epsg-3857}',
                    width: 256,
                    height: 256
                  } : {})
                });

                // Layer objesini sakla
                if (!rl.wmsLayerObjs) rl.wmsLayerObjs = {};
                rl.wmsLayerObjs[layerInfo.name] = wmsLayer;

                // TUCBS i√ßin rastgele se√ßilen layer'ƒ± veya normal i√ßin ilk layer'ƒ± aktif et
                const shouldActivate = isTucbs ? (index === randomIndex) : (index === 0);

                if (shouldActivate) {
                  layerGroup.addLayer(wmsLayer);
                  this.wmsLayerStates[`${resourceId}_${index}`] = true;
                  console.log(`Aktif edilen layer: ${layerInfo.title} (index: ${index})`);
                } else {
                  this.wmsLayerStates[`${resourceId}_${index}`] = false;
                }

                // Opacity state'i kaydet
                this.wmsLayerStates[`${resourceId}_${index}_opacity`] = 100;

                // Hata durumunda log
                wmsLayer.on('tileerror', function (error) {
                  console.error('WMS Tile Error:', error);
                  console.error('Failed URL:', error.tile?.src);
                });
              });

              // Layer Switcher'ƒ± g√∂ster ve g√ºncelle
              document.getElementById('layerSwitcher').style.display = 'block';
              this.renderLayerSwitcherContent();

            } else {
              // Eƒüer layer bilgisi alƒ±namazsa varsayƒ±lan layer kullan
              console.warn('WMS layer bilgisi alƒ±namadƒ±, varsayƒ±lan kullanƒ±lƒ±yor');

              const paneName = this.createPaneForResource(resourceId, true);
              const newLayer = L.tileLayer.wms(url, {
                layers: resource.wms_layer || 'layer',
                format: 'image/png',
                transparent: true,
                version: '1.3.0',
                crs: L.CRS.EPSG3857,
                uppercase: true,
                attribution: `WMS: ${resource.resource_name}`,
                pane: paneName,
                tileSize: 256,
                opacity: 0.8
              });

              newLayer.on('tileerror', function (error) {
                console.error('WMS Tile Error:', error);
              });

              layerGroup.addLayer(newLayer);
            }
            break;
          }
          case 'wfs': {
            const layerName = resource.wfs_layer || 'layer';
            const paneName = this.createPaneForResource(resourceId, true);
            const newLayer = L.tileLayer.wms(url, {
              layers: layerName,
              format: 'image/png',
              transparent: true,
              attribution: `WFS: ${resource.resource_name}`,
              pane: paneName
            });
            layerGroup.addLayer(newLayer);
            break;
          }
          case 'geotiff':
            await this.processGeoTiffData(url, resourceId);
            return;
          default:
            throw new Error('Desteklenmeyen URL tabanlƒ± format: ' + format);
        }
      } catch (error) {
        console.error(`[DEBUG] Katman ekleme hatasƒ± (${format}):`, error);
        this.showResourceError(resourceId, `${(format || '').toUpperCase()} dosyasƒ± i≈ülenemedi: ${error.message}`);
        this.updateResourceToggleState(resourceId, false);
      }
    }

    async processGeoTiffData(url, resourceId) {
      try {
        const rl = this.resourceLayers[resourceId];

        // Edge case: EU Hydro i√ßin √∂zel URL
        if (resourceId === '7acef04c-d0f5-461e-bd19-5940c4e7b520') {
          console.log('EU Hydro River Network GeoTIFF i≈üleniyor');
          url = 'https://dataizmir.izka.org.tr/dataset/8fb7040e-304d-4785-a50a-bb86a341e8f3/resource/7acef04c-d0f5-461e-bd19-5940c4e7b520/download/eu-hydro-river-tetwork-database.tif';
        }

        // GeoTIFF k√ºt√ºphanesi kontrol√º
        if (typeof window.GeoTIFF === 'undefined') {
          console.error('GeoTIFF k√ºt√ºphanesi y√ºklenmemi≈ü');

          // Basit image overlay olarak g√∂ster
          const paneName = this.createPaneForResource(resourceId, true);

          // ƒ∞zmir b√∂lgesi i√ßin tahminƒ± bounds
          const imageBounds = [[37.5, 26.5], [39.5, 28.0]];

          // Direkt URL'den image overlay olu≈ütur
          const imageOverlay = L.imageOverlay(url, imageBounds, {
            opacity: 0.7,
            pane: paneName
          });

          rl.layer.clearLayers();
          rl.layer.addLayer(imageOverlay);

          this.map.fitBounds(imageBounds);
          rl.loaded = true;

          console.log('GeoTIFF basit image overlay olarak eklendi');
          return;
        }

        console.log('GeoTIFF y√ºkleniyor:', url);

        const response = await fetch(url);
        if (!response.ok) throw new Error(`HTTP Error: ${response.status}`);
        const arrayBuffer = await response.arrayBuffer();

        // window.GeoTIFF kullan
        const tiff = await window.GeoTIFF.fromArrayBuffer(arrayBuffer);
        const image = await tiff.getImage();
        const width = image.getWidth();
        const height = image.getHeight();
        const bbox = image.getBoundingBox();

        // Canvas olu≈ütur
        const canvas = document.createElement('canvas');
        const maxSize = 2048;
        const scale = Math.min(maxSize / width, maxSize / height, 1);
        canvas.width = Math.floor(width * scale);
        canvas.height = Math.floor(height * scale);

        const ctx = canvas.getContext('2d');

        // Raster verisini oku
        const rasters = await image.readRasters({
          width: canvas.width,
          height: canvas.height,
          fillValue: 0
        });

        const imageData = ctx.createImageData(canvas.width, canvas.height);
        const data = imageData.data;
        const raster = rasters[0];

        // Min/max deƒüerleri bul
        let min = Infinity, max = -Infinity;
        for (let i = 0; i < raster.length; i++) {
          const val = raster[i];
          if (val !== 0 && !isNaN(val)) {
            min = Math.min(min, val);
            max = Math.max(max, val);
          }
        }

        // Renklendirme
        for (let i = 0; i < raster.length; i++) {
          const value = raster[i];

          if (value === 0 || isNaN(value)) {
            // Transparent
            data[i * 4] = 0;
            data[i * 4 + 1] = 0;
            data[i * 4 + 2] = 0;
            data[i * 4 + 3] = 0;
          } else {
            // Nehir aƒüƒ± i√ßin mavi tonlarƒ±
            const normalized = (value - min) / (max - min);
            data[i * 4] = Math.floor(20 + normalized * 50);
            data[i * 4 + 1] = Math.floor(50 + normalized * 100);
            data[i * 4 + 2] = Math.floor(150 + normalized * 105);
            data[i * 4 + 3] = 255;
          }
        }

        ctx.putImageData(imageData, 0, 0);

        // Image overlay olarak ekle
        const paneName = this.createPaneForResource(resourceId, true);
        const imageBounds = [[bbox[1], bbox[0]], [bbox[3], bbox[2]]];

        const imageOverlay = L.imageOverlay(canvas.toDataURL('image/png'), imageBounds, {
          opacity: 0.8,
          pane: paneName
        });

        rl.layer.clearLayers();
        rl.layer.addLayer(imageOverlay);

        // Haritayƒ± g√∂r√ºnt√ºye odakla
        if (bbox[0] && bbox[2]) {
          this.map.fitBounds(imageBounds, { padding: [50, 50] });
        }

        rl.loaded = true;
        console.log('GeoTIFF ba≈üarƒ±yla render edildi');

      } catch (error) {
        console.error('GeoTIFF i≈üleme hatasƒ±:', error);
        this.showResourceError(resourceId, `GeoTIFF render edilemedi: ${error.message}`);
        this.updateResourceToggleState(resourceId, false);
      }
    }

    async processShpData(shpUrl, resourceId) {
      try {
        const response = await fetch(shpUrl);
        if (!response.ok) throw new Error(`HTTP Error: ${response.status}`);
        const buffer = await response.arrayBuffer();
        const geojson = shp.parseZip(buffer);
        if (!geojson || !geojson.features || geojson.features.length === 0) {
          throw new Error('SHP dosyasƒ±nda veri yok.');
        }
        const rl = this.resourceLayers[resourceId];
        await this.addGeoJSONToLayer(geojson, rl.layer, resourceId);
        rl.loaded = true;
      } catch (error) {
        console.error(`SHP i≈üleme hatasƒ±: ${error}`);
        this.showResourceError(resourceId, `SHP dosyasƒ± i≈ülenemedi: ${error.message}`);
        this.updateResourceToggleState(resourceId, false);
      }
    }

    async addGeoJSONToLayer(geojsonData, layerGroup, resourceId) {
      try {
        layerGroup.clearLayers();
        const resource = this.spatialData.find(r => r.resource_id === resourceId);
        if (!resource) return;

        // Pre-load metadata mappings once for this resource
        await this.getMetadataMappings(resourceId);

        const color = this.getResourceColor(resourceId) || '#888'; // <-- √ñNEMLƒ∞: √∂nce rengi al
        const paneName = this.createPaneForResource(resourceId, false);

        const pointFeatures = [];
        const nonPointFeatures = [];

        // Performans i√ßin sadece g√∂r√ºn√ºr features'ƒ± i≈üle
        const maxFeatures = 5000;
        let features = geojsonData.features || [];

        if (features.length > maxFeatures) {
          console.warn(`√áok fazla feature (${features.length}), ilk ${maxFeatures} tanesi i≈ülenecek`);
          features = features.slice(0, maxFeatures);
        }

        features.forEach(feature => {
          if (feature.geometry && feature.geometry.type === 'Point') {
            pointFeatures.push(feature);
          } else {
            nonPointFeatures.push(feature);
          }
        });



        const cluster = L.markerClusterGroup({
          spiderfyOnEveryZoom: false,
          spiderfyOnMaxZoom: true,
          showCoverageOnHover: false,
          disableClusteringAtZoom: 16,
          maxClusterRadius: 50,
          chunkedLoading: true,
          chunkInterval: 50,
          chunkDelay: 5,
          animate: false,

          // Katman rengi sabit, yoƒüunluƒüa g√∂re opaklƒ±k (istersen boyut) deƒüi≈üsin
          iconCreateFunction: function (cl) {
            var count = cl.getChildCount();

            // Opaklƒ±k e≈üikleri
            var opacity = count < 10 ? 0.65 : (count < 50 ? 0.80 : 1.0);

            var html =
              '<div class="cluster-dot" style="--bg:' + color + ';--opacity:' + opacity + '">'
              + '<span>' + count + '</span>'
              + '</div>';

            return L.divIcon({
              className: 'cluster-icon',
              html: html,
              iconSize: [32, 32],          // sabit
              // iconSize: [size, size],    // adetle b√ºy√ºtmek istersen bunu a√ß
            });
          }
        });

        const getDivIcon = () => L.divIcon({
          className: 'pin-glow',
          html: `<div style="width:14px;height:14px;background:${color};border:2px solid #fff;border-radius:50%"></div>`,
          iconSize: [18, 18],
          iconAnchor: [9, 9]
        });

        // Batch marker ekleme
        const markers = pointFeatures.map(feature => {
          const [lon, lat] = feature.geometry.coordinates;
          const marker = L.marker([lat, lon], {
            icon: getDivIcon(),
            pane: paneName
          });

          // Pre-bind popup with synchronous content (metadata already loaded)
          marker.on('click', () => {
            const popupContent = this.createPopupContentSync(feature, resource);
            marker.bindPopup(popupContent, { maxWidth: 300, className: 'custom-popup' }).openPopup();
          });

          return marker;
        });

        if (markers.length > 0) {
          cluster.addLayers(markers);
        }

        let vectorLayer = null;
        if (nonPointFeatures.length > 0) {
          const nonPointGeoJSON = {
            type: 'FeatureCollection',
            features: nonPointFeatures
          };

          vectorLayer = L.geoJSON(nonPointGeoJSON, {
            pane: paneName,
            style: () => ({
              color: color,
              weight: 3,
              opacity: 1.0,
              fillColor: color,
              fillOpacity: 0.3
            }),
            onEachFeature: (feature, layer) => {
              // Use synchronous version to avoid repeated API calls
              const popupContent = this.createPopupContentSync(feature, resource);
              layer.bindPopup(popupContent, { maxWidth: 300, className: 'custom-popup' });

              if (layer.setStyle) {
                layer.on('mouseover', () => {
                  layer.setStyle({ weight: 4, fillOpacity: 0.5 });
                });
                layer.on('mouseout', () => {
                  layer.setStyle({ weight: 3, fillOpacity: 0.3 });
                });
              }
            }
          });
        }

        if (cluster.getLayers().length > 0) {
          layerGroup.addLayer(cluster);
        }

        if (vectorLayer) {
          layerGroup.addLayer(vectorLayer);
        }

        const rl = this.resourceLayers[resourceId];
        rl._cluster = cluster.getLayers().length > 0 ? cluster : null;
        rl._vector = vectorLayer;

      } catch (error) {
        console.error('[DEBUG] GeoJSON ekleme hatasƒ±:', error);
        this.showResourceError(resourceId, `GeoJSON i≈ülenemedi: ${error.message}`);
      }
    }

    async processApiDataFrontend(apiUrl, resourceId) {
      const rl = this.resourceLayers[resourceId];
      try {
        const res = await fetch(apiUrl, { mode: 'cors' });
        if (!res.ok) throw new Error(`API isteƒüi ba≈üarƒ±sƒ±z: Status ${res.status}`);
        const json = await res.json();
        const dataArray = this.findDataArrayInJson(json);
        if (!dataArray || dataArray.length === 0) {
          throw new Error('API yanƒ±tƒ±nda uygun formatta veri bulunamadƒ±.');
        }
        rl.fetchedData = dataArray;

        const coord = this.smartDetectCoordinateColumnsJS(dataArray);
        if (coord.found) {
          const geojson = this.convertDataToGeoJSON(dataArray, coord.columns);
          await this.addGeoJSONToLayer(geojson, rl.layer, resourceId);
          rl.loaded = true;
        } else {
          await this.showManualColumnSelection(resourceId, coord.columns);
        }
      } catch (error) {
        console.error(`[DEBUG] Frontend API i≈üleme hatasƒ±:`, error);
        this.showResourceError(resourceId, error.message || 'API verisi i≈ülenemedi');
        rl.loaded = false;
        this.updateResourceToggleState(resourceId, false);
      }
    }

    async processGeoJsonFrontend(url, resourceId) {
      const rl = this.resourceLayers[resourceId];
      try {
        const response = await fetch(url, { mode: 'cors', credentials: 'include' });
        if (!response.ok) {
          throw new Error(`Dosya y√ºklenemedi: ${response.status} ${response.statusText}`);
        }
        const geojsonData = await response.json();
        if (geojsonData.type !== 'FeatureCollection' && geojsonData.type !== 'Feature') {
          throw new Error('Ge√ßerli bir GeoJSON dosyasƒ± deƒüil.');
        }
        await this.addGeoJSONToLayer(geojsonData, rl.layer, resourceId);
        rl.loaded = true;
      } catch (error) {
        console.error(`[DEBUG] Frontend GeoJSON i≈üleme hatasƒ±:`, error);
        this.showResourceError(resourceId, error.message || 'GeoJSON y√ºklenemedi');
        rl.loaded = false;
        this.updateResourceToggleState(resourceId, false);
      }
    }

    async createPopupContent(feature, resource) {
      // Load metadata mappings for this resource
      const mappingsData = await this.getMetadataMappings(resource.resource_id);
      const { mappings, visibilityMode, visibleFields, hiddenFields } = mappingsData;

      let content = '<div class="popup-content">';
      content += `<div class="popup-resource-header">${resource.resource_name}<br><small style="opacity:.8;">${resource.format || 'Bilinmiyor'}</small></div>`;

      if (feature.properties && typeof feature.properties === 'object') {
        Object.entries(feature.properties).forEach(([k, v]) => {
          if (v !== null && v !== undefined && v !== '') {
            // Visibility kontrol√º
            if (visibilityMode === 'show_all') {
              // "T√ºm alanlarƒ± g√∂ster" modu - sadece hiddenFields'de olanlarƒ± gizle
              if (hiddenFields && hiddenFields.includes(k)) {
                return; // Skip hidden fields
              }
            } else if (visibilityMode === 'show_selected') {
              // "Sadece se√ßilenleri g√∂ster" modu - sadece visibleFields'de olanlarƒ± g√∂ster
              if (!visibleFields || !visibleFields.includes(k)) {
                return; // Skip non-visible fields
              }
            }

            // Eski hidden kontrol√º (backward compatibility)
            const mapping = mappings[k];
            if (mapping && mapping.hidden) {
              return; // Skip hidden fields
            }

            // Get display name (default to original key)
            const displayName = mapping?.displayName || k;

            // Apply value mapping if exists
            let displayValue = v;
            if (mapping?.valueMapping && mapping.valueMapping[v]) {
              displayValue = mapping.valueMapping[v];
            }

            content += `<div><strong>${displayName}:</strong> <span>${displayValue}</span></div>`;
          }
        });
      }

      content += `<div style="margin-top: 12px; padding-top: 10px; border-top: 1px solid #eee; text-align: center;">
        <a href="/dataset/${resource.package_name}/resource/${resource.resource_id}" target="_blank" style="color:#007bff;text-decoration:none;font-weight:500;">Kaynaƒüƒ± G√∂r√ºnt√ºle ‚Üí</a>
      </div>`;
      content += '</div>';
      return content;
    }

    // Synchronous version that uses cached metadata mappings
    createPopupContentSync(feature, resource) {
      const mappingsData = this.metadataMappingsCache?.[resource.resource_id] || {
        mappings: {}, visibilityMode: 'show_all', visibleFields: [], hiddenFields: []
      };
      const { mappings, visibilityMode, visibleFields, hiddenFields } = mappingsData;

      // Uzun metin sayƒ±lacak etiketler
      const LONG_FIELDS = new Set(['A√áIKLAMA', 'ACIKLAMA', 'ADRES', 'DESCRIPTION', 'ADDRESS']);

      // Ba≈ülƒ±k + kompakt tablo kapsayƒ±cƒ±
      let content = '<div class="popup-content popup-compact">';
      content += `<div class="popup-resource-header">${resource.resource_name}<br><small style="opacity:.8;">${resource.format || 'Bilinmiyor'}</small></div>`;
      content += `<div class="popup-table">`;

      if (feature.properties && typeof feature.properties === 'object') {
        Object.entries(feature.properties).forEach(([k, v]) => {
          if (v === null || v === undefined || v === '') return;

          // G√∂r√ºn√ºrl√ºk kurallarƒ±
          if (visibilityMode === 'show_all') {
            if (hiddenFields && hiddenFields.includes(k)) return;
          } else if (visibilityMode === 'show_selected') {
            if (!visibleFields || !visibleFields.includes(k)) return;
          }
          const mapping = mappings[k];
          if (mapping && mapping.hidden) return;

          const displayName = (mapping?.displayName || k);
          let displayValue = (mapping?.valueMapping && mapping.valueMapping[v]) ? mapping.valueMapping[v] : v;

          // Uzun alanlarda collapsible
          let valueHtml = String(displayValue);
          if (LONG_FIELDS.has(displayName.toString().toUpperCase()) && valueHtml.replace(/<[^>]*>/g, '').length > 140) {
            valueHtml = `
          <div class="collapsible">${valueHtml}</div>
          <button type="button" class="toggle-more">Daha fazla</button>
        `;
          } else {
            valueHtml = `${valueHtml}`;
          }

          content += `
        <div class="popup-row">
          <div class="popup-label">${displayName}</div>
          <div class="popup-value">${valueHtml}</div>
        </div>`;
        });
      }

      content += `</div>`; // .popup-table
      content += `<div style="margin-top:12px;padding-top:10px;border-top:1px solid #eee;text-align:center;">
    <a href="/dataset/${resource.package_name}/resource/${resource.resource_id}" target="_blank" style="color:#007bff;text-decoration:none;font-weight:500;">Kaynaƒüƒ± G√∂r√ºnt√ºle ‚Üí</a>
  </div>`;
      content += `</div>`; // .popup-content
      return content;
    }

    async getMetadataMappings(resourceId, forceRefresh = false) {
      // Cache metadata mappings to avoid repeated API calls
      if (!this.metadataMappingsCache) {
        this.metadataMappingsCache = {};
      }

      // Force refresh bypasses cache
      if (!forceRefresh && this.metadataMappingsCache[resourceId] !== undefined) {
        return this.metadataMappingsCache[resourceId];
      }

      try {
        const response = await fetch(`/api/spatial-resources/${resourceId}/metadata-mappings`, {
          credentials: 'include',
          headers: {
            'Cache-Control': 'no-cache',
            'Pragma': 'no-cache'
          }
        });
        const data = await response.json();

        if (data.success) {
          const result = {
            mappings: data.field_mappings || {},
            visibilityMode: data.visibility_mode || 'show_all',
            visibleFields: data.visible_fields || [],
            hiddenFields: data.hidden_fields || []
          };
          this.metadataMappingsCache[resourceId] = result;
          console.log('Metadata mappings loaded for', resourceId, result);
          return result;
        }
      } catch (error) {
        console.warn('Could not load metadata mappings for', resourceId, error);
      }

      // Return empty mappings if not found or error
      const emptyResult = {
        mappings: {},
        visibilityMode: 'show_all',
        visibleFields: [],
        hiddenFields: []
      };
      this.metadataMappingsCache[resourceId] = emptyResult;
      return emptyResult;
    }

    // Metadata cache'ini temizle
    clearMetadataCache(resourceId = null) {
      if (resourceId) {
        // Sadece belirli bir resource i√ßin cache'i temizle
        delete this.metadataMappingsCache[resourceId];
        console.log('Metadata cache cleared for', resourceId);
      } else {
        // T√ºm cache'i temizle
        this.metadataMappingsCache = {};
        console.log('All metadata cache cleared');
      }
    }

    findDataArrayInJson(jsonData) {
      if (Array.isArray(jsonData)) return jsonData;
      if (typeof jsonData === 'object' && jsonData !== null) {
        const keys = ['data', 'results', 'items', 'onemliyer', 'records', 'features'];
        for (const k of keys) {
          if (k in jsonData && Array.isArray(jsonData[k])) return jsonData[k];
        }
        for (const k in jsonData) {
          if (Array.isArray(jsonData[k]) && jsonData[k].length > 0) return jsonData[k];
        }
      }
      return null;
    }

    smartDetectCoordinateColumnsJS(dataArray) {
      if (!dataArray || dataArray.length === 0) return { found: false, columns: [] };
      const columns = Object.keys(dataArray[0]);
      const latPatterns = [/^(lat|latitude|enlem|y|kuzey)$/i, /lat/i, /enlem/i, /kuzey/i];
      const lonPatterns = [/^(lon|lng|longitude|boylam|x|dogu)$/i, /lon|lng/i, /boylam/i, /dogu/i];
      let latCol = null, lonCol = null;
      for (const p of latPatterns) {
        if (latCol = columns.find(c => p.test(c))) break;
      }
      for (const p of lonPatterns) {
        if (lonCol = columns.find(c => p.test(c))) break;
      }
      if (latCol && lonCol && latCol !== lonCol) {
        return { found: true, columns: { lat: latCol, lon: lonCol } };
      }
      return { found: false, columns };
    }

    convertDataToGeoJSON(dataArray, coordColumns) {
      const features = [];
      const { lat: latCol, lon: lonCol } = coordColumns;
      for (const row of dataArray) {
        try {
          const lat = parseFloat(String(row[latCol]).replace(',', '.'));
          const lon = parseFloat(String(row[lonCol]).replace(',', '.'));
          if (isNaN(lat) || isNaN(lon) || lat < -90 || lat > 90 || lon < -180 || lon > 180) continue;
          const properties = { ...row };
          features.push({
            type: 'Feature',
            geometry: { type: 'Point', coordinates: [lon, lat] },
            properties
          });
        } catch (_) { }
      }
      return { type: 'FeatureCollection', features };
    }

    async processManualSelection(resourceId, buttonElement) {
      const modal = buttonElement.closest('.column-modal-overlay');
      const latCol = modal.querySelector('#latColumn').value;
      const lonCol = modal.querySelector('#lonColumn').value;

      if (!latCol || !lonCol) {
        alert('L√ºtfen enlem ve boylam s√ºtunlarƒ±nƒ± se√ßin');
        return;
      }

      const rl = this.resourceLayers[resourceId];
      if (rl && rl.fetchedData) {
        try {
          const geojson = this.convertDataToGeoJSON(rl.fetchedData, { lat: latCol, lon: lonCol });
          await this.addGeoJSONToLayer(geojson, rl.layer, resourceId);
          rl.loaded = true;
          modal.remove();
        } catch (error) {
          alert('Veri i≈ülenirken hata: ' + error.message);
        }
        return;
      }

      try {
        const response = await fetch(`/api/spatial-resources/${resourceId}/process-manual`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          credentials: 'include',
          body: JSON.stringify({ lat_column: latCol, lon_column: lonCol })
        });
        const result = await response.json();

        if (result.success) {
          await this.addGeoJSONToLayer(result.data, rl.layer, resourceId);
          rl.loaded = true;
          modal.remove();
        } else {
          alert('Veri i≈ülenirken hata: ' + result.error);
        }
      } catch (error) {
        alert('ƒ∞stek g√∂nderilirken hata: ' + error.message);
      }
    }

    getResourceColor(resourceId) {
      // Check if resource has a saved color in spatialData
      const resource = this.spatialData.find(r => r.resource_id === resourceId);
      if (resource && resource.color) {
        return resource.color;
      }

      // Fallback: use hash-based color from palette
      const colors = [
        '#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', '#FECA57',
        '#FF9FF3', '#54A0FF', '#5F27CD', '#00D2D3', '#10AC84',
        '#EE5A24', '#FF6348'
      ];
      const hash = resourceId.split('').reduce((a, b) => {
        a = ((a << 5) - a) + b.charCodeAt(0);
        return a & a;
      }, 0);
      return colors[Math.abs(hash) % colors.length];
    }

    updateResourceToggleState(resourceId, isActive) {
      const checkbox = document.querySelector(`input[data-resource="${resourceId}"]`);
      const resourceItem = document.getElementById(`resource-${resourceId}`);

      if (checkbox) {
        checkbox.checked = isActive;
      }

      if (resourceItem) {
        if (isActive) {
          resourceItem.classList.add('active');
        } else {
          resourceItem.classList.remove('active');
        }
      }
    }

    showResourceError(resourceId, errorMessage) {
      const el = document.getElementById(`resource-${resourceId}`);
      if (el) {
        const info = el.querySelector('.resource-info');
        if (info) {
          info.querySelector('.resource-error')?.remove();
          const div = document.createElement('div');
          div.className = 'resource-error';
          div.style.cssText = 'color:#dc3545;font-size:10px;margin-top:3px;font-style:italic;';
          div.textContent = errorMessage.length > 60 ? errorMessage.substring(0, 60) + '...' : errorMessage;
          div.title = errorMessage;
          info.appendChild(div);
        }
      }
    }

    setFocus(resourceId) {
      if (!this.activeResources.has(resourceId)) return;
      this.focusMode = true;
      this.focusedResourceId = resourceId;
      this.updateEmphasis();
      this.renderSelectedLayersPanel();
    }

    clearFocus() {
      this.focusMode = false;
      this.focusedResourceId = null;
      this.updateEmphasis();
      this.renderSelectedLayersPanel();
    }

    applyEmphasis(resourceId, emphasized) {
      const rl = this.resourceLayers[resourceId];
      if (!rl) return;

      if (rl._vector) {
        try {
          rl._vector.eachLayer(l => {
            if (l.setStyle) {
              l.setStyle({
                opacity: emphasized ? 0.95 : 0.25,
                fillOpacity: emphasized ? 0.25 : 0.12,
                weight: emphasized ? 3 : 1.5
              });
            }
          });
          if (emphasized) rl._vector.bringToFront?.();
        } catch (_) { }
      }

      if (rl._cluster) {
        rl._cluster.eachLayer(m => {
          if (m.setOpacity) m.setOpacity(emphasized ? 1.0 : 0.35);
        });
        if (emphasized) rl._cluster.bringToFront?.();
      }

      rl.layer?.eachLayer(l => {
        if (l.setOpacity) l.setOpacity(emphasized ? 1.0 : 0.35);
      });
    }

    updateEmphasis() {
      const hasActive = this.activeResources.size > 0;
      Object.keys(this.resourceLayers).forEach(id => {
        let emphasized = true;
        if (this.focusMode && this.focusedResourceId) {
          emphasized = (id === this.focusedResourceId);
        } else if (!hasActive) {
          emphasized = true;
        }
        this.applyEmphasis(id, emphasized);
      });
    }

    fitMapToActiveLayers() {
      if (this.activeResources.size === 0) return;

      // Throttle this operation
      if (this.renderThrottle) clearTimeout(this.renderThrottle);

      this.renderThrottle = setTimeout(() => {
        const allBounds = [];
        this.activeResources.forEach(resourceId => {
          const rl = this.resourceLayers[resourceId];
          if (rl && rl.visible && rl.layer.getLayers().length > 0) {
            rl.layer.eachLayer(layer => {
              if (layer.getBounds) {
                allBounds.push(layer.getBounds());
              } else if (layer.getLatLng) {
                const ll = layer.getLatLng();
                allBounds.push(L.latLngBounds([ll, ll]));
              }
            });
          }
        });

        if (allBounds.length > 0) {
          const group = new L.featureGroup();
          allBounds.forEach(b => group.addLayer(L.rectangle(b, { opacity: 0 })));
          if (group.getLayers().length > 0) {
            this.map.fitBounds(group.getBounds(), { padding: [20, 20], animate: false });
          }
        }
      }, 100);
    }

    renderSelectedLayersPanel() {
      const panel = document.getElementById('selectedLayersPanel');
      const ids = [...this.activeResources];

      if (ids.length === 0) {
        panel.style.display = 'none';
        return;
      }

      panel.style.display = 'flex';

      const chips = ids.map(id => {
        const res = this.resourceLayers[id].resource;
        const color = this.getResourceColor(id);
        const focused = (this.focusMode && this.focusedResourceId === id);
        return `
          <div class="sel-chip" data-res="${id}">
            <div class="sel-dot" style="background:${color}"></div>
            <div class="sel-name">${res.resource_name}</div>
            <div class="sel-actions">
              <button class="sel-btn ${focused ? 'active' : ''}" onclick="spatialMapManager.onChipFocus('${id}')" title="Odaƒüƒ± bu katmana al">üéØ</button>
              <button class="sel-btn" onclick="spatialMapManager.showRelatedData('${id}')" title="ƒ∞li≈ükili verileri g√∂r√ºnt√ºle">üìä</button>
              <button class="sel-btn danger" onclick="spatialMapManager.onChipClose('${id}')" title="Kapat">‚úï</button>
            </div>
          </div>`;
      }).join('');

      const clearBtn = (this.focusMode && this.focusedResourceId)
        ? `<div class="sel-chip" style="grid-template-columns:auto;gap:6px;justify-items:center;">
             <button class="sel-btn" onclick="spatialMapManager.clearFocus()" title="Odaƒüƒ± temizle">Odaƒüƒ± Temizle</button>
           </div>`
        : '';

      panel.innerHTML = clearBtn + chips;
    }

    onChipFocus(resourceId) {
      if (this.focusMode && this.focusedResourceId === resourceId) {
        this.clearFocus();
      } else {
        this.setFocus(resourceId);
      }
    }

    onChipClose(resourceId) {
      this.toggleResource(resourceId, false);
    }

    togglePackageCollapse(packageId) {
      if (this.collapsedPackages.has(packageId)) {
        this.collapsedPackages.delete(packageId);
      } else {
        this.collapsedPackages.add(packageId);
      }
      const container = document.getElementById(`resources-${packageId}`);
      const indicator = document.getElementById(`indicator-${packageId}`);
      if (container && indicator) {
        const collapsed = this.collapsedPackages.has(packageId);
        container.classList.toggle('collapsed', collapsed);
        indicator.classList.toggle('collapsed', collapsed);
      }
    }

    handleResourceClick(resourceId, event) {
      event.preventDefault();
      event.stopPropagation();

      const checkbox = event.currentTarget.querySelector('input[type="checkbox"]');
      const isCurrentlyActive = this.activeResources.has(resourceId);

      // Toggle state
      const newState = !isCurrentlyActive;

      // Update checkbox
      if (checkbox) {
        checkbox.checked = newState;
      }

      // Toggle resource
      this.toggleResource(resourceId, newState);
    }

    setupEventListeners() {
      // Arama
      const searchInput = document.getElementById('layerSearch');
      let t;
      searchInput.addEventListener('input', () => {
        clearTimeout(t);
        t = setTimeout(() => {
          this.searchTerm = searchInput.value.toLowerCase();
          this.renderLayers();
        }, 250);
      });

      // Organization filter
      document.getElementById('organizationFilter').addEventListener('change', (e) => {
        this.selectedOrganization = e.target.value;
        this.renderLayers();
      });

      // Format filter
      document.getElementById('formatFilter').addEventListener('change', (e) => {
        this.selectedFormat = e.target.value;
        this.renderLayers();
      });

      // Theme filter
      document.getElementById('themeFilter').addEventListener('change', (e) => {
        this.selectedTheme = e.target.value;
        this.renderLayers();
      });

      // Category filter
      document.getElementById('categoryFilter').addEventListener('change', (e) => {
        this.selectedCategory = e.target.value;
        this.renderLayers();
      });

      // YENƒ∞: Pencere yeniden boyutlandƒ±rma dinleyicisi
      window.addEventListener('resize', () => {
        // Sadece localStorage'da kayƒ±t yoksa (varsayƒ±lan durumdaysa)
        // pozisyonu sƒ±fƒ±rla.
        if (!localStorage.getItem('legendPosition')) {
          this.setDefaultLegendPosition();
        }
      });
    }

    renderLayers() {
      const container = document.getElementById('spatialLayersContainer');
      if (this.spatialData.length === 0) {
        container.innerHTML = `<div class="error-section">Hen√ºz mekansal kaynak bulunamadƒ±.<br><small>Y√∂netim panelinden kaynaklarƒ± mekansal olarak i≈üaretleyin.</small></div>`;
        return;
      }

      const filteredGroups = this.filterPackages();
      const html = Object.values(filteredGroups).map(pg => this.renderPackageGroup(pg)).join('');

      if (Object.keys(filteredGroups).length === 0) {
        container.innerHTML = `<div class="error-section">Filtrelere uygun kaynak bulunamadƒ±.</div>`;
      } else {
        container.innerHTML = html;
      }
    }

    renderPackageGroup(group) {
      const isCollapsed = this.collapsedPackages.has(group.id);
      const filteredResources = group.resources || [];
      if (filteredResources.length === 0) return '';

      const theme = group.theme || 'Tema yok';
      const categories = group.groups?.map(g => g.display_name || g.name).join(', ') || 'Kategori yok';

      return `
        <div class="package-group" id="package-${group.id}">
          <div class="package-header" onclick="spatialMapManager.togglePackageCollapse('${group.id}')">
            <div class="package-title-row">
              <h4 class="package-title">${group.name}</h4>
              <button class="collapse-indicator ${isCollapsed ? 'collapsed' : ''}" id="indicator-${group.id}">‚ñº</button>
            </div>
            <div class="package-meta">
              <span class="resource-count">${filteredResources.length} kaynak</span>
              <span class="theme-badge">${theme}</span>
              <span class="category-badge">${categories}</span>
            </div>
          </div>
          <div class="resources-container ${isCollapsed ? 'collapsed' : ''}" id="resources-${group.id}">
            ${filteredResources.map(r => this.renderResourceItem(r)).join('')}
          </div>
        </div>`;
    }

    renderResourceItem(resource) {
      const format = (resource.format || 'other').toLowerCase();
      const formatClass = this.getFormatClass(format);
      const activeClass = this.activeResources.has(resource.resource_id) ? 'active' : '';
      const extraClass = ['wms', 'geotiff'].includes(format) ? `${format}-resource` : '';

      return `
        <div class="resource-item ${activeClass} ${extraClass}" 
             id="resource-${resource.resource_id}">
          <div class="resource-info">
            <div class="resource-name" title="${resource.resource_name}">${resource.resource_name}</div>
            <div class="resource-meta">
              <span class="format-badge ${formatClass}">${format.toUpperCase()}</span>
            </div>
          </div>
          <div class="resource-actions">
            <button class="download-resource-btn" 
                    onclick="spatialMapManager.downloadResourceData('${resource.resource_id}')"
                    title="Veriyi indir">
              <span>üíæ</span>
              <span>ƒ∞ndir</span>
            </button>
            <label class="modern-toggle" onclick="spatialMapManager.handleResourceClick('${resource.resource_id}', event)">
              <input type="checkbox" 
                     data-resource="${resource.resource_id}" 
                     ${this.activeResources.has(resource.resource_id) ? 'checked' : ''}>
              <span class="toggle-slider"></span>
            </label>
          </div>
        </div>`;
    }

    getFormatClass(format) {
      const map = {
        'csv': 'format-csv', 'json': 'format-json', 'geojson': 'format-geojson',
        'xlsx': 'format-xlsx', 'xls': 'format-xlsx', 'shp': 'format-shp',
        'kml': 'format-kml', 'api': 'format-api', 'rest': 'format-api',
        'wms': 'format-wms', 'geotiff': 'format-geotiff'
      };
      return map[format] || 'format-other';
    }

    updateStats() {
      const totalResources = this.spatialData.length;
      const totalPackages = Object.keys(this.packageGroups).length;
      const activeResourceCount = this.activeResources.size;
      const totalFormats = [...new Set(this.spatialData.map(r => r.format))].filter(Boolean).length;

      document.getElementById('totalSpatialResources').textContent = totalResources.toLocaleString('tr-TR');
      document.getElementById('totalSpatialPackages').textContent = totalPackages.toLocaleString('tr-TR');
      document.getElementById('activeLayers').textContent = activeResourceCount.toLocaleString('tr-TR');
      document.getElementById('totalFormats').textContent = totalFormats.toLocaleString('tr-TR');
    }

    showManualColumnSelection(resourceId, columns) {
      return new Promise((resolve) => {
        const modal = document.createElement('div');
        modal.className = 'column-modal-overlay';
        modal.innerHTML = `
          <style>
            .column-modal-overlay {
              position:fixed;top:0;left:0;width:100%;height:100%;
              background:rgba(0,0,0,0.5);z-index:2000;
              display:flex;align-items:center;justify-content:center;
            }
            .column-modal {
              background:#fff;padding:22px;border-radius:12px;
              max-width:450px;width:90%;box-shadow:0 10px 30px rgba(0,0,0,0.2);
            }
            .column-modal h3 {
              margin-bottom:16px;color:#2c3e50;font-size:18px;
            }
            .column-select-group {
              margin:12px 0;
            }
            .column-select-group label {
              display:block;margin-bottom:8px;font-weight:500;color:#495057;
            }
            .column-select-group select {
              width:100%;padding:10px 12px;border:1px solid #ced4da;
              border-radius:6px;font-size:14px;background:#fff;
            }
            .modal-actions {
              margin-top:18px;display:flex;justify-content:flex-end;gap:10px;
            }
            .modal-btn {
              padding:10px 16px;border:none;border-radius:6px;
              font-weight:500;cursor:pointer
            }
            .modal-btn.cancel {
              background:#6c757d;color:#fff;
            }
            .modal-btn.primary {
              background:#007bff;color:#fff;
            }
            .modal-btn:hover {
              opacity:.9;
            }
          </style>
          <div class="column-modal">
            <h3>Koordinat S√ºtunlarƒ±nƒ± Se√ßin</h3>
            <div class="column-select-group">
              <label>Enlem (Latitude) S√ºtunu:</label>
              <select id="latColumn">
                <option value="">Se√ßiniz...</option>
                ${columns.map(col => `<option value="${col}">${col}</option>`).join('')}
              </select>
            </div>
            <div class="column-select-group">
              <label>Boylam (Longitude) S√ºtunu:</label>
              <select id="lonColumn">
                <option value="">Se√ßiniz...</option>
                ${columns.map(col => `<option value="${col}">${col}</option>`).join('')}
              </select>
            </div>
            <div class="modal-actions">
              <button class="modal-btn cancel" onclick="this.closest('.column-modal-overlay').remove()">ƒ∞ptal</button>
              <button class="modal-btn primary" onclick="spatialMapManager.processManualSelection('${resourceId}', this)">Uygula</button>
            </div>
          </div>`;
        document.body.appendChild(modal);
        resolve();
      });
    }

    async showRelatedData(resourceId) {
      try {
        const modal = document.getElementById('relatedDataModal');
        const content = document.getElementById('relatedDataContent');

        modal.style.display = 'flex';

        content.innerHTML = `
          <div style="text-align: center; padding: 40px; color: #6c757d;">
            <div style="font-size: 48px; margin-bottom: 16px;">‚è≥</div>
            <p>Y√ºkleniyor...</p>
          </div>
        `;

        console.log('üîÑ Loading related data for:', resourceId);

        const response = await fetch(`/api/spatial-resources/${resourceId}/relationships`, {
          credentials: 'include'
        });

        const data = await response.json();

        if (!data.success) {
          throw new Error(data.error || 'ƒ∞li≈ükili veriler y√ºklenemedi');
        }

        const relationships = data.relationships || [];
        const resource = this.resourceLayers[resourceId]?.resource;

        if (relationships.length === 0) {
          content.innerHTML = `
            <div style="text-align: center; padding: 40px; color: #6c757d;">
              <div style="font-size: 48px; margin-bottom: 16px;">üì≠</div>
              <h3>ƒ∞li≈ükili veri bulunamadƒ±</h3>
              <p><strong>${resource?.resource_name || 'Bu kaynak'}</strong> i√ßin hen√ºz ili≈ükilendirilmi≈ü veri yok.</p>
            </div>
          `;
          return;
        }

        content.innerHTML = `
          <div style="margin-bottom: 16px;">
            <div style="background: #f8f9fa; padding: 12px; border-radius: 8px; margin-bottom: 16px;">
              <div style="font-size: 14px; font-weight: 600; color: #495057;">
                üó∫Ô∏è ${resource?.resource_name || 'Mekansal Kaynak'}
              </div>
              <div style="font-size: 12px; color: #6c757d; margin-top: 4px;">
                ${relationships.length} ili≈ükili veri seti
              </div>
            </div>

            <div style="display: flex; flex-direction: column; gap: 12px;">
              ${relationships.map(rel => {
          const formatClass = this.getFormatClass((rel.related_resource_format || 'other').toLowerCase());
          return `
                  <div style="background: white; border: 2px solid #e9ecef; border-radius: 8px; padding: 12px; transition: all 0.2s;"
                       onmouseover="this.style.borderColor='#667eea'; this.style.background='#f8f9fa';"
                       onmouseout="this.style.borderColor='#e9ecef'; this.style.background='white';">
                    <div style="display: flex; justify-content: space-between; align-items: start; margin-bottom: 8px;">
                      <div style="flex: 1;">
                        <div style="font-size: 14px; font-weight: 600; color: #495057; margin-bottom: 4px;">
                          üìÑ ${rel.related_resource_name}
                        </div>
                        <div style="font-size: 12px; color: #6c757d;">
                          üìÅ ${rel.package_title || 'Bilinmiyor'}
                        </div>
                      </div>
                      <span class="format-badge ${formatClass}">${rel.related_resource_format}</span>
                    </div>

                    <div style="display: flex; gap: 8px; margin-top: 12px;">
                      <a href="/dataset/${rel.package_name}/resource/${rel.related_resource_id}"
                         target="_blank"
                         style="flex: 1; background: #28a745; color: white; border: none; padding: 8px 12px; border-radius: 6px; font-size: 12px; font-weight: 600; text-align: center; text-decoration: none; transition: all 0.2s;"
                         onmouseover="this.style.background='#218838'"
                         onmouseout="this.style.background='#28a745'">
                        üëÅÔ∏è G√∂r√ºnt√ºle
                      </a>
                      ${rel.related_resource_url ? `
                        <a href="${rel.related_resource_url}"
                           target="_blank"
                           download
                           style="flex: 1; background: #007bff; color: white; border: none; padding: 8px 12px; border-radius: 6px; font-size: 12px; font-weight: 600; text-align: center; text-decoration: none; transition: all 0.2s;"
                           onmouseover="this.style.background='#0056b3'"
                           onmouseout="this.style.background='#007bff'">
                          ‚¨áÔ∏è ƒ∞ndir
                        </a>
                      ` : ''}
                    </div>
                  </div>
                `;
        }).join('')}
            </div>
          </div>
        `;

      } catch (error) {
        console.error('‚ùå Error loading related data:', error);
        document.getElementById('relatedDataContent').innerHTML = `
          <div style="text-align: center; padding: 40px; color: #dc3545;">
            <div style="font-size: 48px; margin-bottom: 16px;">‚ùå</div>
            <h3>Hata olu≈ütu</h3>
            <p>${error.message}</p>
          </div>
        `;
      }
    }

    closeRelatedDataModal() {
      document.getElementById('relatedDataModal').style.display = 'none';
    }

    getFormatClass(format) {
      const map = {
        'csv': 'format-csv', 'json': 'format-json', 'geojson': 'format-geojson',
        'xml': 'format-xml', 'pdf': 'format-pdf', 'xls': 'format-xls',
        'xlsx': 'format-xlsx', 'shp': 'format-shp', 'kml': 'format-kml'
      };
      return map[format] || 'format-other';
    }

    showError(message) {
      const container = document.getElementById('spatialLayersContainer');
      container.innerHTML = `<div class="error-section">${message}</div>`;
    }

    // ==================== CUSTOM LEGEND METHODS ====================

    toggleCustomLegend() {
      const legendBox = document.getElementById('customLegendBox');
      if (legendBox) {
        legendBox.classList.toggle('collapsed');
      }
    }

    // Lejant kutusunu s√ºr√ºklenebilir yapar
    // Lejant kutusunu s√ºr√ºklenebilir yapar
    initDraggableLegend() {
      const legendBox = document.getElementById('customLegendBox');
      const legendHeader = legendBox?.querySelector('.custom-legend-header');

      if (!legendBox || !legendHeader) return;

      let isDragging = false;
      let startX, startY;
      let initialLeft, initialTop;

      // Mouse down - s√ºr√ºkleme ba≈ülangƒ±cƒ±
      legendHeader.addEventListener('mousedown', (e) => {
        // Toggle butonuna tƒ±klanmƒ±≈üsa s√ºr√ºklemeyi ba≈ülatma
        if (e.target.classList.contains('custom-legend-header-toggle')) return;

        isDragging = true;
        legendBox.classList.add('dragging');

        const computedStyle = window.getComputedStyle(legendBox);

        // G√úNCELLEME: 'left' deƒüerini al
        initialLeft = parseInt(computedStyle.left) || 0;

        // G√úNCELLEME: 'top' pozisyonunu al
        if (computedStyle.top !== 'auto') {
          // Zaten 'top' ile pozisyonlanmƒ±≈ü
          initialTop = parseInt(computedStyle.top) || 0;
        } else {
          // 'bottom' ile pozisyonlanmƒ±≈ü, 'top'a √ßevir
          const rect = legendBox.getBoundingClientRect();
          const containerRect = legendBox.parentElement.getBoundingClientRect();
          initialTop = rect.top - containerRect.top;
        }

        // Pozisyonu 'top' bazlƒ± olarak g√ºncelle
        legendBox.style.top = initialTop + 'px';
        legendBox.style.bottom = 'auto'; // 'bottom'u devre dƒ±≈üƒ± bƒ±rak

        // Ba≈ülangƒ±√ß mouse pozisyonu
        startX = e.clientX;
        startY = e.clientY;

        // Se√ßimi engelle
        e.preventDefault();
      });

      // Mouse move - s√ºr√ºkleme
      document.addEventListener('mousemove', (e) => {
        if (!isDragging) return;

        // Mouse hareketini hesapla
        const deltaX = e.clientX - startX;
        const deltaY = e.clientY - startY;

        // Viewport boyutlarƒ±nƒ± al
        const viewportWidth = window.innerWidth;
        const viewportHeight = window.innerHeight;

        // Yeni pozisyon
        let newLeft = initialLeft + deltaX;
        let newTop = initialTop + deltaY;

        // Box boyutlarƒ±
        const boxWidth = legendBox.offsetWidth;
        const boxHeight = legendBox.offsetHeight;

        // Viewport i√ßinde sƒ±nƒ±rla - sayfa dƒ±≈üƒ±na √ßƒ±kmasƒ±n
        newLeft = Math.max(0, Math.min(newLeft, viewportWidth - boxWidth));
        newTop = Math.max(0, Math.min(newTop, viewportHeight - boxHeight));

        // Pozisyonu uygula
        legendBox.style.left = newLeft + 'px';
        legendBox.style.top = newTop + 'px';
        legendBox.style.right = 'auto';
        legendBox.style.bottom = 'auto';
      });

      // Mouse up - s√ºr√ºkleme biti≈üi
      document.addEventListener('mouseup', () => {
        if (isDragging) {
          isDragging = false;
          legendBox.classList.remove('dragging');

          // Pozisyonu localStorage'a kaydet
          localStorage.setItem('legendPosition', JSON.stringify({
            left: legendBox.style.left,
            top: legendBox.style.top
          }));
        }
      });

      // Touch events for mobile
      legendHeader.addEventListener('touchstart', (e) => {
        if (e.target.classList.contains('custom-legend-header-toggle')) return;

        isDragging = true;
        legendBox.classList.add('dragging');

        const touch = e.touches[0];
        startX = touch.clientX;
        startY = touch.clientY;

        // G√úNCELLEME: Mousedown ile aynƒ± mantƒ±k
        const computedStyle = window.getComputedStyle(legendBox);
        initialLeft = parseInt(computedStyle.left) || 0;

        if (computedStyle.top !== 'auto') {
          initialTop = parseInt(computedStyle.top) || 0;
        } else {
          const rect = legendBox.getBoundingClientRect();
          const containerRect = legendBox.parentElement.getBoundingClientRect();
          initialTop = rect.top - containerRect.top;
        }

        legendBox.style.top = initialTop + 'px';
        legendBox.style.bottom = 'auto';
        // G√úNCELLEME SONU

        e.preventDefault();
      });

      document.addEventListener('touchmove', (e) => {
        if (!isDragging) return;

        const touch = e.touches[0];
        const deltaX = touch.clientX - startX;
        const deltaY = touch.clientY - startY;

        // Viewport boyutlarƒ±nƒ± al
        const viewportWidth = window.innerWidth;
        const viewportHeight = window.innerHeight;

        let newLeft = initialLeft + deltaX;
        let newTop = initialTop + deltaY;

        const boxWidth = legendBox.offsetWidth;
        const boxHeight = legendBox.offsetHeight;

        // Viewport i√ßinde sƒ±nƒ±rla - sayfa dƒ±≈üƒ±na √ßƒ±kmasƒ±n
        newLeft = Math.max(0, Math.min(newLeft, viewportWidth - boxWidth));
        newTop = Math.max(0, Math.min(newTop, viewportHeight - boxHeight));

        legendBox.style.left = newLeft + 'px';
        legendBox.style.top = newTop + 'px';
        legendBox.style.right = 'auto';
        legendBox.style.bottom = 'auto';
      });

      document.addEventListener('touchend', () => {
        if (isDragging) {
          isDragging = false;
          legendBox.classList.remove('dragging');

          // Pozisyonu localStorage'a kaydet
          localStorage.setItem('legendPosition', JSON.stringify({
            left: legendBox.style.left,
            top: legendBox.style.top
          }));
        }
      });

      // Kaydedilmi≈ü pozisyonu y√ºkle
      this.restoreLegendPosition();
    }
    // YENƒ∞: Varsayƒ±lan (sol alt) pozisyonu ayarlar
    setDefaultLegendPosition() {
      const legendBox = document.getElementById('customLegendBox');
      if (!legendBox) return;

      // 'left' ve 'bottom' kullanarak sol alt k√∂≈üeye sabitle
      legendBox.style.left = '10px';
      legendBox.style.bottom = '10px';
      legendBox.style.top = 'auto';
      legendBox.style.right = 'auto';
    }


    // G√úNCELLEME: Kaydedilmi≈ü lejant pozisyonunu geri y√ºkle
    restoreLegendPosition() {
      const legendBox = document.getElementById('customLegendBox');
      if (!legendBox) return;

      const savedPosition = localStorage.getItem('legendPosition');
      if (savedPosition) {
        try {
          const position = JSON.parse(savedPosition); // { left: "150px", top: "300px" }

          // Sadece ge√ßerli, kaydedilmi≈ü bir pozisyon (left/top) varsa uygula
          if (position.left && position.top) {
            legendBox.style.left = position.left;
            legendBox.style.top = position.top;
            legendBox.style.right = 'auto';
            legendBox.style.bottom = 'auto';
            return; // Ba≈üarƒ±yla y√ºklendi
          }
        } catch (e) {
          console.error('Could not restore legend position:', e);
        }
      }

      // Kayƒ±tlƒ± pozisyon yoksa veya hatalƒ±ysa, varsayƒ±lanƒ± (sol alt) ayarla
      // Bu, √∂ƒüe gizliyken bile √ßalƒ±≈üƒ±r.
      this.setDefaultLegendPosition();
    }

    // Lejant kutusunu 4 taraftan boyutlandƒ±rƒ±labilir yapar
    initResizableLegend() {
      const legendBox = document.getElementById('customLegendBox');
      const resizeHandles = legendBox?.querySelectorAll('.custom-legend-resize-handle');

      if (!legendBox || !resizeHandles || resizeHandles.length === 0) return;

      let isResizing = false;
      let resizeDirection = null;
      let startX, startY;
      let startWidth, startHeight, startLeft, startTop;

      // Her handle i√ßin mousedown event ekle
      resizeHandles.forEach(handle => {
        handle.addEventListener('mousedown', (e) => {
          isResizing = true;
          resizeDirection = handle.dataset.direction;

          // Mevcut boyut ve pozisyonu al
          const rect = legendBox.getBoundingClientRect();
          startWidth = rect.width;
          startHeight = rect.height;
          startLeft = rect.left;
          startTop = rect.top;

          // Ba≈ülangƒ±√ß mouse pozisyonu
          startX = e.clientX;
          startY = e.clientY;

          // G√∂rsel feedback
          legendBox.classList.add('resizing');

          // Se√ßimi engelle
          e.preventDefault();
          e.stopPropagation();
        });
      });

      // Mouse move - boyutlandƒ±rma
      const handleMouseMove = (e) => {
        if (!isResizing || !resizeDirection) return;

        // Prevent default browser behavior
        e.preventDefault();

        const deltaX = e.clientX - startX;
        const deltaY = e.clientY - startY;

        // Viewport sƒ±nƒ±rlarƒ±
        const viewportWidth = window.innerWidth;
        const viewportHeight = window.innerHeight;

        let newWidth = startWidth;
        let newHeight = startHeight;
        let newLeft = startLeft;
        let newTop = startTop;

        // Minimum boyutlar
        const minWidth = 200;
        const minHeight = 100;

        // Y√∂n bazlƒ± resize
        switch (resizeDirection) {
          case 'right':
            newWidth = Math.max(minWidth, Math.min(startWidth + deltaX, viewportWidth - startLeft - 10));
            break;

          case 'left':
            const maxLeftShift = startWidth - minWidth;
            const actualLeftShift = Math.min(deltaX, maxLeftShift);
            newWidth = startWidth - actualLeftShift;
            newLeft = Math.max(10, startLeft + actualLeftShift);
            break;

          case 'bottom':
            newHeight = Math.max(minHeight, Math.min(startHeight + deltaY, viewportHeight - startTop - 10));
            break;

          case 'top':
            const maxTopShift = startHeight - minHeight;
            const actualTopShift = Math.min(deltaY, maxTopShift);
            newHeight = startHeight - actualTopShift;
            newTop = Math.max(10, startTop + actualTopShift);
            break;

          case 'bottom-right':
            newWidth = Math.max(minWidth, Math.min(startWidth + deltaX, viewportWidth - startLeft - 10));
            newHeight = Math.max(minHeight, Math.min(startHeight + deltaY, viewportHeight - startTop - 10));
            break;

          case 'bottom-left':
            const maxLeftShiftBL = startWidth - minWidth;
            const actualLeftShiftBL = Math.min(deltaX, maxLeftShiftBL);
            newWidth = startWidth - actualLeftShiftBL;
            newLeft = Math.max(10, startLeft + actualLeftShiftBL);
            newHeight = Math.max(minHeight, Math.min(startHeight + deltaY, viewportHeight - startTop - 10));
            break;

          case 'top-right':
            newWidth = Math.max(minWidth, Math.min(startWidth + deltaX, viewportWidth - startLeft - 10));
            const maxTopShiftTR = startHeight - minHeight;
            const actualTopShiftTR = Math.min(deltaY, maxTopShiftTR);
            newHeight = startHeight - actualTopShiftTR;
            newTop = Math.max(10, startTop + actualTopShiftTR);
            break;

          case 'top-left':
            const maxLeftShiftTL = startWidth - minWidth;
            const actualLeftShiftTL = Math.min(deltaX, maxLeftShiftTL);
            newWidth = startWidth - actualLeftShiftTL;
            newLeft = Math.max(10, startLeft + actualLeftShiftTL);

            const maxTopShiftTL = startHeight - minHeight;
            const actualTopShiftTL = Math.min(deltaY, maxTopShiftTL);
            newHeight = startHeight - actualTopShiftTL;
            newTop = Math.max(10, startTop + actualTopShiftTL);
            break;
        }

        // Viewport sƒ±nƒ±rlarƒ±nƒ± kontrol et
        if (newLeft + newWidth > viewportWidth - 10) {
          newWidth = viewportWidth - newLeft - 10;
        }
        if (newTop + newHeight > viewportHeight - 10) {
          newHeight = viewportHeight - newTop - 10;
        }

        // Stil uygula - GER√áEK ZAMANLI
        requestAnimationFrame(() => {
          legendBox.style.width = `${newWidth}px`;
          legendBox.style.height = `${newHeight}px`;
          legendBox.style.minHeight = `${newHeight}px`;
          legendBox.style.maxHeight = `${newHeight}px`;
          legendBox.style.left = `${newLeft}px`;
          legendBox.style.top = `${newTop}px`;
        });
      };

      document.addEventListener('mousemove', handleMouseMove);

      // Mouse up - boyutlandƒ±rma biti≈üi
      document.addEventListener('mouseup', () => {
        if (isResizing) {
          isResizing = false;
          resizeDirection = null;
          legendBox.classList.remove('resizing');

          // Manuel resize yapƒ±ldƒ±ƒüƒ±nƒ± i≈üaretle
          legendBox.classList.add('manually-resized');
          legendBox.style.setProperty('--manual-height', legendBox.style.height);

          // Boyut ve pozisyonu localStorage'a kaydet
          localStorage.setItem('legendSize', JSON.stringify({
            width: legendBox.style.width,
            height: legendBox.style.height
          }));
          localStorage.setItem('legendPosition', JSON.stringify({
            left: legendBox.style.left,
            top: legendBox.style.top
          }));
          localStorage.setItem('legendManuallyResized', 'true');
        }
      });

      // Kaydedilmi≈ü boyutu y√ºkle
      this.restoreLegendSize();
    }

    // Kaydedilmi≈ü lejant boyutunu geri y√ºkle
    restoreLegendSize() {
      const legendBox = document.getElementById('customLegendBox');
      if (!legendBox) return;

      // Default boyutlar - HER ZAMAN bunlarla ba≈üla
      const defaultWidth = '150px';
      const defaultHeight = '150px';

      // localStorage'ƒ± TAMAMEN TEMƒ∞ZLE - her seferinde yeni ba≈üla
      localStorage.removeItem('legendSize');
      localStorage.removeItem('legendPosition');
      localStorage.removeItem('legendManuallyResized');

      // √ñNCE HER ≈ûEYƒ∞ TEMƒ∞ZLE - t√ºm inline style'larƒ± kaldƒ±r
      legendBox.removeAttribute('style');
      legendBox.classList.remove('manually-resized');

      // ≈ûƒ∞MDƒ∞ default boyutlarƒ± uygula
      legendBox.style.width = defaultWidth;
      legendBox.style.height = defaultHeight;
      legendBox.style.minHeight = defaultHeight;
      legendBox.style.maxHeight = defaultHeight;

      console.log('Legend box reset to default: 150x150');
    }

    async loadCustomLegend(resourceId) {
      // Deprecated - use loadAllCustomLegends instead
      await this.loadAllCustomLegends();
    }

    hideCustomLegend() {
      const legendBox = document.getElementById('customLegendBox');
      if (legendBox) {
        legendBox.classList.remove('active');
      }
    }

    async loadAllCustomLegends() {
¬† ¬† ¬† const legendBox = document.getElementById('customLegendBox');
¬† ¬† ¬† const entriesEl = document.getElementById('customLegendEntries');

¬† ¬† ¬† if (!legendBox || !entriesEl) return;

¬† ¬† ¬† // D√úZELTME 1: 'active' sƒ±nƒ±fƒ±nƒ± buradan kaldƒ±rƒ±yoruz.
¬† ¬† ¬† // Sadece veri bulunduƒüunda ekleyeceƒüiz.

¬† ¬† ¬† const activeResourceIds = Array.from(this.activeResources);

¬† ¬† ¬† if (activeResourceIds.length === 0) {
¬† ¬† ¬† ¬† // Aktif kaynak yoksa kutuyu gizle
¬† ¬† ¬† ¬† legendBox.classList.remove('active'); // D√úZELTME 1
¬† ¬† ¬† ¬† entriesEl.innerHTML = `
¬† ¬† ¬† ¬† ¬† <div class="custom-legend-empty">
¬† ¬† ¬† ¬† ¬† ¬† <div class="custom-legend-empty-icon">üìù</div>
¬† ¬† ¬† ¬† ¬† ¬† <div>Aktif kaynak yok</div>
¬† ¬† ¬† ¬† ¬† </div>
¬† ¬† ¬† ¬† `;
¬† ¬† ¬† ¬† return;
¬† ¬† ¬† }

¬† ¬† ¬† try {
¬† ¬† ¬† ¬† // Fetch legends for all active resources
¬† ¬† ¬† ¬† const legendPromises = activeResourceIds.map(async resourceId => {
¬† ¬† ¬† ¬† ¬† try {
¬† ¬† ¬† ¬† ¬† ¬† // D√úZELTME 2: Login olmadan public verileri √ßekebilmek i√ßin 'credentials' eklendi.
¬† ¬† ¬† ¬† ¬† ¬† const response = await fetch(`/api/spatial-resources/${resourceId}/legends`, {
¬† ¬† ¬† ¬† ¬† ¬† ¬† credentials: 'include'
¬† ¬† ¬† ¬† ¬† ¬† });
¬† ¬† ¬† ¬† ¬† ¬† const data = await response.json();

¬† ¬† ¬† ¬† ¬† ¬† if (!data.success || !data.legends || data.legends.length === 0) {
¬† ¬† ¬† ¬† ¬† ¬† ¬† return null;
¬† ¬† ¬† ¬† ¬† ¬† }

¬† ¬† ¬† ¬† ¬† ¬† // Get resource info
¬† ¬† ¬† ¬† ¬† ¬† const resource = this.spatialData.find(r => r.resource_id === resourceId);
¬† ¬† ¬† ¬† ¬† ¬† const resourceName = resource ? (resource.resource_name || 'ƒ∞simsiz Kaynak') : 'Kaynak';

¬† ¬† ¬† ¬† ¬† ¬† return {
¬† ¬† ¬† ¬† ¬† ¬† ¬† resourceId,
¬† ¬† ¬† ¬† ¬† ¬† ¬† resourceName,
¬† ¬† ¬† ¬† ¬† ¬† ¬† legends: data.legends
¬† ¬† ¬† ¬† ¬† ¬† };
¬† ¬† ¬† ¬† ¬† } catch (error) {
¬† ¬† ¬† ¬† ¬† ¬† console.error(`Error loading legends for ${resourceId}:`, error);
¬† ¬† ¬† ¬† ¬† ¬† return null;
¬† ¬† ¬† ¬† ¬† }
¬† ¬† ¬† ¬† });

¬† ¬† ¬† ¬† const allResourceLegends = (await Promise.all(legendPromises)).filter(item => item !== null);

¬† ¬† ¬† ¬† if (allResourceLegends.length === 0) {
¬† ¬† ¬† ¬† ¬† // Lejant verisi yoksa kutuyu gizle
¬† ¬† ¬† ¬† ¬† legendBox.classList.remove('active'); // D√úZELTME 1
¬† ¬† ¬† ¬† ¬† entriesEl.innerHTML = `
¬† ¬† ¬† ¬† ¬† ¬† <div class="custom-legend-empty">
¬† ¬† ¬† ¬† ¬† ¬† ¬† <div class="custom-legend-empty-icon">üìù</div>
¬† ¬† ¬† ¬† ¬† ¬† ¬† <div>Aktif kaynaklar i√ßin lejant bilgisi yok</div>
¬† ¬† ¬† ¬† ¬† ¬† </div>
¬† ¬† ¬† ¬† ¬† `;
¬† ¬† ¬† ¬† ¬† return;
¬† ¬† ¬† ¬† }

¬† ¬† ¬† ¬† // D√úZELTME 1: Veri bulundu! Kutuyu ≈üimdi g√∂ster.
¬† ¬† ¬† ¬† legendBox.classList.add('active');
¬† ¬† ¬† ¬† legendBox.classList.remove('collapsed');

¬† ¬† ¬† ¬† // Render all legends grouped by resource
const entriesHTML = allResourceLegends.map(resourceLegends => {
¬† ¬† ¬† ¬† ¬† const legendItems = resourceLegends.legends.map(legend => `
<div style="display: flex; gap: 12px; align-items: center; padding: 8px 0; white-space: nowrap;">
  <div style="font-size: 11px; font-weight: 600; color: #6c757d; white-space: nowrap;">
    ${resourceLegends.resourceName}
  </div>
  <div class="custom-legend-entry-color" style="background-color: ${legend.color}; width: 32px; height: 32px; border-radius: 6px; border: 2px solid white; box-shadow: 0 2px 6px rgba(0,0,0,0.15); flex-shrink: 0;"></div>
  <div style="font-size: 13px; color: #495057; font-weight: 500; white-space: nowrap;">
    ${legend.description}
  </div>
</div>
`).join('');

¬† ¬† ¬† ¬† ¬† return legendItems;
¬† ¬† ¬† ¬† }).join('<div style="border-top: 2px solid #e9ecef; margin: 8px 0;"></div>');

¬† ¬† ¬† ¬† entriesEl.innerHTML = entriesHTML;

¬† ¬† ¬† ¬† const totalLegends = allResourceLegends.reduce((sum, r) => sum + r.legends.length, 0);
¬† ¬† ¬† ¬† console.log(`‚úÖ Loaded ${totalLegends} legend entries from ${allResourceLegends.length} resources`);

¬† ¬† ¬† } catch (error) {
¬† ¬† ¬† ¬† console.error('‚ùå Error loading custom legends:', error);
¬† ¬† ¬† ¬† legendBox.classList.remove('active'); // D√úZELTME 1 (Hata durumunda da gizle)
¬† ¬† ¬† }
¬† ¬† }
    async updateCustomLegendForActiveResources() {
      // Load legends for ALL active resources
      await this.loadAllCustomLegends();
    }
  }

  let spatialMapManager;
  document.addEventListener('DOMContentLoaded', () => {
    spatialMapManager = new SpatialMapManager();
  });
  // "A√áIKLAMA" deƒüerini DOM'dan bulup collapsible yap (etiket <b>/<strong>/span ile yazƒ±lsa bile)
  const DESC_LABELS = ['A√áIKLAMA', 'ACIKLAMA', 'DESCRIPTION'];

  function enhanceDescriptionArea(containerEl) {
    if (!containerEl) return;

    // 1) Etiketi ta≈üƒ±yan node'u bul (kalƒ±n/etiketli yazƒ±lmƒ±≈ü olabilir)
    const nodes = containerEl.querySelectorAll('*');
    let labelEl = null;
    for (const el of nodes) {
      const t = (el.innerText || '').trim().replace(/:$/, '').toUpperCase();
      if (DESC_LABELS.includes(t)) { labelEl = el; break; }
    }
    if (!labelEl) return; // a√ßƒ±klama etiketini bulamadƒ±

    // 2) Deƒüerin bulunduƒüu √∂ƒüeyi yakala
    //    - yaygƒ±n durumda "etiket" ile "deƒüer" yan yana (aynƒ± satƒ±r) veya bir sonraki karde≈ü blokta duruyor.
    //    - √∂nce aynƒ± satƒ±rdaki etiketten ":" sonrasƒ± metni yakalamayƒ± dene:
    let valueEl = null;

    // a) Aynƒ± parent i√ßinde, labelEl'den sonra gelen ilk "deƒüer" benzeri karde≈ü
    const siblings = Array.from(labelEl.parentElement ? labelEl.parentElement.childNodes : []);
    const idx = siblings.indexOf(labelEl);
    if (idx > -1) {
      // label'dan sonra gelen node'larda metin/HTML arayan basit tarama
      for (let i = idx + 1; i < siblings.length; i++) {
        const n = siblings[i];
        const text = (n.textContent || '').trim();
        // bo≈ü olmayan ve ":" deƒüilse deƒüer kabul et
        if (text && !DESC_LABELS.includes(text.replace(/:$/, '').toUpperCase())) {
          // metin d√ºƒü√ºm√º ise sarmalamak i√ßin bir span yarat
          if (n.nodeType === Node.TEXT_NODE) {
            const span = document.createElement('span');
            span.innerHTML = n.textContent;
            n.replaceWith(span);
            valueEl = span;
          } else if (n.nodeType === Node.ELEMENT_NODE) {
            valueEl = n;
          }
          break;
        }
      }
    }

    // b) Bulunamadƒ±ysa: labelEl'in en yakƒ±n "sonraki karde≈ü element"ini deƒüer kabul et
    if (!valueEl) {
      let el = labelEl;
      while (el && !valueEl) {
        el = el.nextElementSibling;
        if (el && (el.innerText || '').trim()) valueEl = el;
      }
    }

    if (!valueEl) return;

    // 3) Zaten collapsible yapƒ±lmƒ±≈ü mƒ±?
    if (valueEl.closest('.collapsible')) return;

    // 4) Deƒüeri collapsible sar
    const originalHTML = valueEl.innerHTML;
    const wrapper = document.createElement('div');
    wrapper.className = 'collapsible';
    wrapper.innerHTML = originalHTML;

    const btn = document.createElement('button');
    btn.type = 'button';
    btn.className = 'toggle-more';
    btn.textContent = 'Daha fazla';

    // Deƒüer elemanƒ±nƒ± temizleyip yeni yapƒ±yƒ± yerle≈ütir
    valueEl.innerHTML = '';
    valueEl.appendChild(wrapper);
    valueEl.appendChild(btn);
  }

  // Leaflet popup a√ßƒ±ldƒ±ƒüƒ±nda a√ßƒ±klamayƒ± zorla collapsible yap
  (function hookDescOnly() {
    const bind = (mapLike) => {
      if (!mapLike || !mapLike.on) return;
      mapLike.on('popupopen', (ev) => {
        const contentEl = ev?.popup?._contentNode || ev?.popup?.getElement()?.querySelector('.leaflet-popup-content');
        if (!contentEl) return;
        // √ñnce bizim tabloya √ßevrim i≈ülemi √ßalƒ±≈üsƒ±n (eklediysen)
        // Ardƒ±ndan a√ßƒ±klamayƒ± kesinle≈ütir:
        enhanceDescriptionArea(contentEl);
      });
    };

    if (window.map) bind(window.map);
    document.addEventListener('DOMContentLoaded', () => window.map && bind(window.map));
  })();
  document.addEventListener('click', (e) => {
    const btn = e.target.closest('.toggle-more');
    if (!btn) return;
    const box = btn.previousElementSibling;
    if (!box || !box.classList.contains('collapsible')) return;
    const expanded = box.classList.toggle('expanded');
    btn.textContent = expanded ? 'Daha az' : 'Daha fazla';
  });
  (function () {
    const section = document.getElementById('filterSection');
    const btn = document.getElementById('mobileFilterToggle');
    const mq = window.matchMedia('(max-width: 900px)');

    if (!section || !btn) return;

    function applyInitialState() {
      // Mobilde ba≈ülangƒ±√ßta kapalƒ±, masa√ºst√ºnde her zaman a√ßƒ±k
      if (mq.matches) {
        section.classList.remove('open');
        btn.setAttribute('aria-expanded', 'false');
      } else {
        section.classList.add('open');
        btn.setAttribute('aria-expanded', 'true');
      }
    }

    btn.addEventListener('click', () => {
      const isOpen = section.classList.toggle('open');
      btn.setAttribute('aria-expanded', isOpen ? 'true' : 'false');
    });

    // Ekran boyutu deƒüi≈üince doƒüru durumu uygula
    mq.addEventListener ? mq.addEventListener('change', applyInitialState)
      : mq.addListener(applyInitialState); // eski tarayƒ±cƒ±lar

    // ƒ∞lk y√ºklemede durumu ayarla
    applyInitialState();
  })();

</script>
{% endblock %}