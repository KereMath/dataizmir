{% extends "package/base.html" %}

{% set res = resource %}

{% block head_extras -%}
  {{ super() }}
  {% set description = h.markdown_extract(h.get_translated(res, 'description'), extract_length=200) if res.description else h.markdown_extract(h.get_translated(package, 'notes'), extract_length=200) %}
  <meta property="og:title" content="{{ h.dataset_display_name(package) }} - {{ h.resource_display_name(res) }} - {{ g.site_title }}">
  <meta property="og:description" content="{{ description|forceescape }}">

  <!-- Leaflet for Spatial View -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

  <!-- Leaflet MarkerCluster -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.css" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.Default.css" />
  <script src="https://unpkg.com/leaflet.markercluster@1.5.3/dist/leaflet.markercluster.js"></script>

  <!-- SHP.js for Shapefile support -->
  <script src="https://unpkg.com/shpjs@3.6.0/dist/shp.min.js"></script>

  <style>
    .nav-tabs-plain {
      display:none !important;
    }
    .table {
      margin-bottom: 0px !important;
    }
    /* Modern Resource Page CSS - Embedded */
    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&display=swap');

    body {
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif !important;
      background: linear-gradient(135deg, #f8fafc 0%, #e2e8f0 100%) !important;
      font-size: 17px !important;
    }

    .breadcrumb {
      background: rgba(255, 255, 255, 0.9) !important;
      backdrop-filter: blur(10px) !important;
      border: 1px solid rgba(226, 232, 240, 0.6) !important;
      border-radius: 12px !important;
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.05) !important;
      font-size: 16px !important;
    }

    .module {
      background: rgba(255, 255, 255, 0.95) !important;
      border: 1px solid rgba(226, 232, 240, 0.8) !important;
      border-radius: 16px !important;
      box-shadow: 0 8px 30px rgba(0, 0, 0, 0.08) !important;
      transition: all 0.3s ease !important;
    }

    .module:hover {
      transform: translateY(-2px) !important;
      box-shadow: 0 12px 40px rgba(0, 0, 0, 0.12) !important;
    }

    .module-content {
      padding: 2rem !important;
      font-size: 17px !important;
    }

    .module-resource {
      border-left: 4px solid #667eea !important;
    }

    .page-heading {
      font-size: 2.75rem !important;
      font-weight: 700 !important;
      background: linear-gradient(135deg, #667eea, #764ba2) !important;
      -webkit-background-clip: text !important;
      background-clip: text !important;
      -webkit-text-fill-color: transparent !important;
      margin-bottom: 1.5rem !important;
    }

    .prose p, .prose ul, .prose ol {
      font-size: 17px !important;
      line-height: 1.7 !important;
    }

    table.table {
      font-size: 16px !important;
    }

    /* WMS Layer Switcher Styles */
    .layer-switcher-control {
      position: absolute;
      top: 10px;
      right: 10px;
      background: white;
      border-radius: 8px;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
      z-index: 1000;
      min-width: 280px;
      max-width: 380px;
      max-height: 70vh;
      overflow-y: auto;
      font-size: 15px;
    }

    .layer-switcher-header {
      background: linear-gradient(135deg, #007bff, #0056b3);
      color: white;
      padding: 12px 16px;
      font-weight: 600;
      font-size: 16px;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .layer-switcher-toggle {
      background: none;
      border: none;
      color: white;
      cursor: pointer;
      font-size: 16px;
    }

    .layer-switcher-content {
      padding: 10px;
      display: none;
    }

    .layer-switcher-content.expanded {
      display: block;
    }

    .layer-switcher-item {
      display: flex;
      align-items: center;
      padding: 8px;
      border-bottom: 1px solid #f0f0f0;
    }

    .layer-switcher-item:last-child {
      border-bottom: none;
    }

    .layer-switcher-checkbox {
      margin-right: 10px;
    }

    .layer-switcher-label {
      flex: 1;
      font-size: 15px;
      color: #495057;
      cursor: pointer;
    }

    .layer-switcher-opacity {
      display: flex;
      align-items: center;
      gap: 5px;
      margin-left: 20px;
      padding: 5px 0;
    }

    .opacity-slider {
      flex: 1;
      cursor: pointer;
    }

    .opacity-value {
      font-size: 11px;
      color: #6c757d;
      min-width: 35px;
      text-align: right;
    }

    .wms-layer-info {
      background: #f8f9fa;
      border-radius: 4px;
      padding: 8px;
      margin: 5px 0;
      font-size: 11px;
      color: #6c757d;
    }

    .wms-layer-list {
      list-style: none;
      padding: 0;
      margin: 5px 0;
    }

    .wms-layer-list li {
      padding: 3px 0;
      border-bottom: 1px solid #e9ecef;
    }

    /* Map controls */
    .basemap-control {
      position: absolute;
      top: 10px;
      left: 10px;
      background: white;
      border-radius: 8px;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
      z-index: 1000;
      overflow: hidden;
    }

    .basemap-button {
      padding: 10px 14px;
      border: none;
      background: white;
      cursor: pointer;
      font-size: 15px;
      font-weight: 500;
      color: #495057;
      transition: all 0.2s;
      border-right: 1px solid #e9ecef;
    }

    .basemap-button:last-child {
      border-right: none;
    }

    .basemap-button:hover {
      background: #f8f9fa;
    }

    .basemap-button.active {
      background: #007bff;
      color: white;
    }

    .map-loading {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      z-index: 1001;
      background: white;
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
    }

    .map-loading.hidden {
      display: none;
    }

    .spinner {
      border: 3px solid #f3f3f3;
      border-top: 3px solid #007bff;
      border-radius: 50%;
      width: 40px;
      height: 40px;
      animation: spin 1s linear infinite;
      margin: 0 auto 10px;
    }

    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
  </style>
{% endblock -%}

{% block subtitle %}{{ h.dataset_display_name(package) }} {{ g.template_title_delimiter }} {{ h.resource_display_name(res) }}{% endblock %}

{% block pre_primary %}
  {% block resource %}
    <section class="module module-resource" role="complementary">
      {% block resource_inner %}
      <div class="module-content">
        <div class="actions">
          {% block resource_actions %}
          <ul>
            {% block resource_actions_inner %}
            {% if h.check_access('package_update', {'id':pkg.id }) and not is_activity_archive %}
              <li>{% link_for _('Manage'), named_route=pkg.type ~ '_resource.edit', id=pkg.name, resource_id=res.id, class_='btn btn-default', icon='wrench' %}</li>
            {% endif %}
            {% if res.url and h.is_url(res.url) %}
              <li>
                <a class="btn btn-primary resource-url-analytics resource-type-{{ res.resource_type }}" href="{{ res.url }}">
                  {% if res.resource_type in ('listing', 'service') %}
                    <i class="fa fa-eye"></i> {{ _('View') }}
                  {% elif res.resource_type == 'api' or res.format|lower == 'api' %}
                    <i class="fa fa-code"></i> {{ _('API Endpoint') }}
                  {% elif not res.has_views and not res.url_type == 'upload' %}
                    <i class="fa fa-external-link"></i> {{ _('Go to resource') }}
                  {% else %}
                    <i class="fa fa-arrow-circle-o-down"></i> {{ _('Download') }}
                  {% endif %}
                </a>
              </li>
            {% endif %}
            {% endblock %}
          </ul>
          {% endblock %}
        </div>
        {% block resource_content %}
          {% block resource_read_title %}<h1 class="page-heading">{{ h.resource_display_name(res) | truncate(50) }}</h1>{% endblock %}
          {% block resource_read_url %}
            {% if res.url and h.is_url(res.url) %}
              <p class="text-muted ellipsis">{{ _('URL:') }} <a class="resource-url-analytics" href="{{ res.url }}" title="{{ res.url }}">{{ res.url }}</a></p>
            {% elif res.url %}
              <p class="text-muted break-word">{{ _('URL:') }} {{ res.url }}</p>
            {% endif %}
          {% endblock %}
          <div class="prose notes" property="rdfs:label">
            {% if res.description %}
              {{ h.render_markdown(res.description) }}
            {% endif %}
          </div>
        {% endblock %}
      </div>
      {% if not is_activity_archive %}
      {% block data_preview %}
      {% block resource_view %}

        {# SPATIAL MAP - No tabs, direct render #}
        <div id="spatial-map-container" style="display: none; position: relative;">
          <!-- Basemap Control -->
          <div class="basemap-control">
            <button class="basemap-button active" data-basemap="sokak">üó∫Ô∏è Sokak</button>
            <button class="basemap-button" data-basemap="uydu">üõ∞Ô∏è Uydu</button>
            <button class="basemap-button" data-basemap="arazi">‚õ∞Ô∏è Arazi</button>
            <button class="basemap-button" data-basemap="sade">üìç Sade</button>
          </div>

          <!-- WMS Layer Switcher -->
          <div class="layer-switcher-control" id="layerSwitcher" style="display: none;">
            <div class="layer-switcher-header">
              <span>üóÇÔ∏è Katman Kontrol√º</span>
              <button class="layer-switcher-toggle" onclick="toggleLayerSwitcher()">‚ñº</button>
            </div>
            <div class="layer-switcher-content" id="layerSwitcherContent">
              <!-- Dinamik olarak doldurulacak -->
            </div>
          </div>

          <!-- Loading spinner -->
          <div class="map-loading" id="mapLoading">
            <div class="spinner"></div>
            <div style="text-align: center; color: #495057;">Veri y√ºkleniyor...</div>
          </div>

          <div id="leaflet-map" style="width: 100%; height: calc(100vh - 200px); min-height: 700px;"></div>
        </div>

        {# Standard Preview - Hidden if spatial #}
        <div id="standard-preview-container">
          <!-- Standard preview content here -->
        </div>

        <script>
          console.log('=== RESOURCE PAGE LOADED (Enhanced with SHP/WMS) ===');

          // Global variables for WMS management
          let wmsLayers = {};
          let wmsLayerStates = {};
          let layerSwitcherExpanded = false;

          // Toggle layer switcher
          function toggleLayerSwitcher() {
            layerSwitcherExpanded = !layerSwitcherExpanded;
            const content = document.getElementById('layerSwitcherContent');
            const toggle = document.querySelector('.layer-switcher-toggle');

            if (layerSwitcherExpanded) {
              content.classList.add('expanded');
              toggle.textContent = '‚ñ≤';
            } else {
              content.classList.remove('expanded');
              toggle.textContent = '‚ñº';
            }
          }

          // Toggle individual WMS layer
          function toggleWMSLayer(resourceId, layerName, layerIndex) {
            const layerId = `${resourceId}_${layerIndex}`;
            const checkbox = document.getElementById(`layer_${layerId}`);
            const isChecked = checkbox.checked;

            wmsLayerStates[layerId] = isChecked;

            const layer = wmsLayers[`${resourceId}_${layerName}`];
            if (layer) {
              if (isChecked) {
                layer.addTo(window.spatialMap);
              } else {
                window.spatialMap.removeLayer(layer);
              }
            }
          }

          // Update WMS layer opacity
          function updateWMSOpacity(resourceId, layerName, value, layerIndex) {
            const layerId = `${resourceId}_${layerIndex}`;
            const opacity = value / 100;

            wmsLayerStates[layerId + '_opacity'] = value;

            const opacityValue = document.querySelector(`#layer_${layerId}`).parentElement.nextElementSibling.querySelector('.opacity-value');
            if (opacityValue) {
              opacityValue.textContent = value + '%';
            }

            const layer = wmsLayers[`${resourceId}_${layerName}`];
            if (layer) {
              layer.setOpacity(opacity);
            }
          }

          // Enhanced Spatial Data Handler
          class ResourceSpatialHandler {
            constructor(resourceId, map) {
              this.resourceId = resourceId;
              this.map = map;
              this.layer = L.layerGroup().addTo(map);
              this.layerPanes = {};
              this.currentBaseMap = 'sokak';
              this.baseMaps = {};
              
              this.initBaseMaps();
              this.setupBasemapControls();
            }

            initBaseMaps() {
              this.baseMaps = {
                sokak: L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                  maxZoom: 19,
                  attribution: '¬© OpenStreetMap'
                }),
                uydu: L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
                  maxZoom: 17,
                  attribution: '¬© Esri'
                }),
                arazi: L.tileLayer('https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png', {
                  maxZoom: 17,
                  attribution: '¬© OpenTopoMap'
                }),
                sade: L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png', {
                  maxZoom: 19,
                  attribution: '¬© CARTO'
                })
              };

              // Add default basemap
              this.baseMaps[this.currentBaseMap].addTo(this.map);
            }

            setupBasemapControls() {
              document.querySelectorAll('.basemap-button').forEach(btn => {
                btn.addEventListener('click', (e) => {
                  const basemap = e.target.dataset.basemap;
                  this.switchBasemap(basemap);
                });
              });
            }

            switchBasemap(basemap) {
              if (basemap === this.currentBaseMap) return;

              this.map.removeLayer(this.baseMaps[this.currentBaseMap]);
              this.baseMaps[basemap].addTo(this.map);
              this.currentBaseMap = basemap;

              document.querySelectorAll('.basemap-button').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.basemap === basemap);
              });
            }

            createPaneForResource(resourceId, isRaster = false) {
              if (this.layerPanes[resourceId]) return this.layerPanes[resourceId];
              const paneName = `pane_${resourceId}`;
              const pane = this.map.createPane(paneName);
              pane.style.zIndex = isRaster ? 350 : 450;
              this.layerPanes[resourceId] = paneName;
              return paneName;
            }

            showLoading() {
              const loading = document.getElementById('mapLoading');
              if (loading) loading.classList.remove('hidden');
            }

            hideLoading() {
              const loading = document.getElementById('mapLoading');
              if (loading) loading.classList.add('hidden');
            }

            async loadData() {
              try {
                this.showLoading();
                
                const apiUrl = `/api/spatial-resources/${this.resourceId}/data`;
                const response = await fetch(apiUrl, { credentials: 'include' });

                if (!response.ok) {
                  throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }

                const result = await response.json();
                console.log('‚úì API Result:', result);

                if (!result.success) {
                  throw new Error(result.error || 'Bilinmeyen API hatasƒ±');
                }

                // Handle different data types
                if (result.type === 'shp') {
                  await this.processShpData(result.url);
                } else if (result.type === 'wms') {
                  await this.addWMSLayer(result.url);
                } else if (result.type === 'api') {
                  await this.processApiData(result.url);
                } else if (result.type === 'geojson_url') {
                  await this.processGeoJsonUrl(result.url);
                } else if (result.type === 'geojson' && result.data) {
                  this.addGeoJSON(result.data);
                } else if (result.type === 'tabular' && result.data) {
                  this.addGeoJSON(result.data);
                } else if (result.type === 'spatial_shp' && result.data) {
                  // Backend'den i≈ülenmi≈ü SHP verisi
                  this.addGeoJSON(result.data);
                } else {
                  console.warn('Desteklenmeyen format:', result.type);
                }

                this.fitMapToBounds();
                this.hideLoading();

              } catch (error) {
                console.error('‚ùå Data load hatasƒ±:', error);
                this.hideLoading();
                this.showError(error.message);
              }
            }

            async processShpData(shpUrl) {
              console.log('üóÇÔ∏è Processing SHP:', shpUrl);
              try {
                // Frontend SHP processing with shp.js
                const response = await fetch(shpUrl);
                if (!response.ok) throw new Error(`HTTP Error: ${response.status}`);
                
                const buffer = await response.arrayBuffer();
                const geojson = await shp.parseZip(buffer);
                
                if (!geojson || !geojson.features || geojson.features.length === 0) {
                  throw new Error('SHP dosyasƒ±nda veri yok.');
                }
                
                console.log(`‚úì SHP parsed: ${geojson.features.length} features`);
                this.addGeoJSON(geojson);
                
              } catch (error) {
                console.error('SHP parse hatasƒ±:', error);
                throw new Error('SHP dosyasƒ± i≈ülenemedi: ' + error.message);
              }
            }

            async extractWMSLayersInfo(url) {
              try {
                // GetCapabilities isteƒüi
                const capabilitiesUrl = url.includes('?')
                  ? `${url}&service=WMS&request=GetCapabilities&version=1.3.0`
                  : `${url}?service=WMS&request=GetCapabilities&version=1.3.0`;

                console.log('GetCapabilities URL:', capabilitiesUrl);

                const response = await fetch(capabilitiesUrl);
                const text = await response.text();

                // Parse XML
                const parser = new DOMParser();
                const xmlDoc = parser.parseFromString(text, "text/xml");

                const layers = [];
                const layerElements = xmlDoc.getElementsByTagName("Layer");

                // TUCBS servisleri i√ßin √∂zel durum
                if (url.includes('tucbs') || url.includes('csb.gov.tr')) {
                  for (let i = 0; i < layerElements.length; i++) {
                    const layer = layerElements[i];
                    const nameEl = layer.getElementsByTagName("Name")[0];
                    const titleEl = layer.getElementsByTagName("Title")[0];

                    if (nameEl && nameEl.textContent && layer.getAttribute('queryable') === '1') {
                      const hasChildLayers = layer.getElementsByTagName("Layer").length > 0;
                      
                      if (!hasChildLayers) {
                        layers.push({
                          name: nameEl.textContent,
                          title: titleEl ? titleEl.textContent : nameEl.textContent,
                          queryable: true
                        });
                      }
                    }
                  }
                } else {
                  // Diƒüer WMS servisleri
                  for (let i = 1; i < layerElements.length; i++) {
                    const layer = layerElements[i];
                    const nameEl = layer.getElementsByTagName("Name")[0];
                    const titleEl = layer.getElementsByTagName("Title")[0];

                    if (nameEl && nameEl.textContent) {
                      layers.push({
                        name: nameEl.textContent,
                        title: titleEl ? titleEl.textContent : nameEl.textContent,
                        queryable: layer.getAttribute('queryable') === '1'
                      });
                    }
                  }
                }

                console.log('Bulunan WMS Layers:', layers);
                return layers;
              } catch (error) {
                console.warn('WMS Layer bilgileri alƒ±namadƒ±:', error);
                return [];
              }
            }

            async addWMSLayer(url) {
              console.log('üó∫Ô∏è Adding WMS Layer:', url);
              try {
                // Get WMS layers info
                const layers = await this.extractWMSLayersInfo(url);
                
                if (layers.length > 0) {
                  // Store WMS layers globally
                  const resourceId = this.resourceId;
                  
                  // TUCBS i√ßin rastgele bir layer se√ß
                  const isTucbs = url.includes('tucbs') || url.includes('csb.gov.tr');
                  const randomIndex = isTucbs ? Math.floor(Math.random() * layers.length) : 0;
                  
                  const paneName = this.createPaneForResource(resourceId, true);
                  
                  // Create WMS layers
                  layers.forEach((layerInfo, index) => {
                    const wmsLayer = L.tileLayer.wms(url, {
                      layers: layerInfo.name,
                      format: 'image/png',
                      transparent: true,
                      version: '1.3.0',
                      crs: L.CRS.EPSG3857,
                      uppercase: true,
                      attribution: `WMS: ${layerInfo.title}`,
                      pane: paneName,
                      tileSize: 256,
                      opacity: 1.0,
                      ...(isTucbs ? {
                        srs: 'EPSG:3857',
                        bbox: '{bbox-epsg-3857}',
                        width: 256,
                        height: 256
                      } : {})
                    });

                    // Store layer globally
                    wmsLayers[`${resourceId}_${layerInfo.name}`] = wmsLayer;

                    // Activate default layer
                    const shouldActivate = isTucbs ? (index === randomIndex) : (index === 0);
                    
                    if (shouldActivate) {
                      this.layer.addLayer(wmsLayer);
                      wmsLayerStates[`${resourceId}_${index}`] = true;
                      console.log(`Aktif edilen layer: ${layerInfo.title} (index: ${index})`);
                    } else {
                      wmsLayerStates[`${resourceId}_${index}`] = false;
                    }

                    wmsLayerStates[`${resourceId}_${index}_opacity`] = 100;

                    // Error handler
                    wmsLayer.on('tileerror', function (error) {
                      console.error('WMS Tile Error:', error);
                    });
                  });

                  // Show and update layer switcher
                  this.renderLayerSwitcherContent(layers);
                  
                } else {
                  // Fallback: Use default layer
                  console.warn('WMS layer bilgisi alƒ±namadƒ±, varsayƒ±lan kullanƒ±lƒ±yor');
                  
                  const paneName = this.createPaneForResource(this.resourceId, true);
                  const wmsLayer = L.tileLayer.wms(url, {
                    layers: 'layer',
                    format: 'image/png',
                    transparent: true,
                    version: '1.3.0',
                    crs: L.CRS.EPSG3857,
                    uppercase: true,
                    attribution: 'WMS Layer',
                    pane: paneName,
                    tileSize: 256,
                    opacity: 0.8
                  });

                  wmsLayer.on('tileerror', function (error) {
                    console.error('WMS Tile Error:', error);
                  });

                  this.layer.addLayer(wmsLayer);
                }
                
                console.log('‚úì WMS Layer added');
              } catch (error) {
                console.error('WMS Layer hatasƒ±:', error);
                throw new Error('WMS Layer eklenemedi: ' + error.message);
              }
            }

            renderLayerSwitcherContent(layers) {
              const switcher = document.getElementById('layerSwitcher');
              const content = document.getElementById('layerSwitcherContent');
              
              if (!switcher || !content) return;
              
              // Show layer switcher
              switcher.style.display = 'block';
              
              let html = '<div class="wms-layer-info"><strong>WMS Katmanlarƒ±</strong><div class="wms-layer-list">';
              
              layers.forEach((layer, index) => {
                const layerId = `${this.resourceId}_${index}`;
                const isChecked = wmsLayerStates[layerId] !== false;
                const opacity = wmsLayerStates[layerId + '_opacity'] || 100;
                
                html += `
                  <div class="layer-switcher-item">
                    <input type="checkbox" 
                           id="layer_${layerId}" 
                           class="layer-switcher-checkbox"
                           ${isChecked ? 'checked' : ''}
                           onchange="toggleWMSLayer('${this.resourceId}', '${layer.name}', ${index})">
                    <label for="layer_${layerId}" class="layer-switcher-label">
                      ${layer.title || layer.name}
                    </label>
                  </div>
                  <div class="layer-switcher-opacity">
                    <span style="font-size: 11px;">üìä</span>
                    <input type="range" 
                           class="opacity-slider" 
                           min="0" max="100" 
                           value="${opacity}"
                           oninput="updateWMSOpacity('${this.resourceId}', '${layer.name}', this.value, ${index})">
                    <span class="opacity-value">${opacity}%</span>
                  </div>
                `;
              });
              
              html += '</div></div>';
              content.innerHTML = html;
            }

            async processApiData(url) {
              console.log('üîó Processing API:', url);
              try {
                const response = await fetch(url);
                const json = await response.json();

                // Parse API response
                let data = json;
                if (typeof json === 'object' && !Array.isArray(json)) {
                  const keys = ['onemliyer', 'data', 'results', 'items', 'records', 'features'];
                  for (const key of keys) {
                    if (json[key] && Array.isArray(json[key])) {
                      data = json[key];
                      break;
                    }
                  }
                }

                if (Array.isArray(data)) {
                  let count = 0;
                  let skippedCount = 0;
                  
                  data.forEach(item => {
                    // Smart coordinate detection - CASE INSENSITIVE
                    // Check all possible variations including capitalized versions
                    const lat = item.Enlem || item.ENLEM || item.enlem || 
                                item.Latitude || item.latitude || item.LATITUDE ||
                                item.Lat || item.lat || item.LAT ||
                                item.y || item.Y;
                    
                    const lon = item.Boylam || item.BOYLAM || item.boylam || 
                                item.Longitude || item.longitude || item.LONGITUDE ||
                                item.Lon || item.lon || item.LON ||
                                item.Lng || item.lng || item.LNG ||
                                item.x || item.X;

                    if (lat && lon) {
                      // Parse coordinates (handle both number and string formats)
                      const latNum = parseFloat(lat);
                      const lonNum = parseFloat(lon);
                      
                      // Validate coordinates
                      if (!isNaN(latNum) && !isNaN(lonNum) && 
                          latNum >= -90 && latNum <= 90 && 
                          lonNum >= -180 && lonNum <= 180) {
                        
                        const marker = L.circleMarker([latNum, lonNum], {
                          radius: 6,
                          fillColor: "#667eea",
                          color: "#fff",
                          weight: 2,
                          fillOpacity: 0.8
                        });

                        // Create popup
                        let popupContent = '<div class="popup-content">';
                        Object.keys(item).forEach(key => {
                          // Exclude coordinate fields from popup
                          const keyLower = key.toLowerCase();
                          if (!['enlem', 'boylam', 'latitude', 'longitude', 'lat', 'lon', 'lng', 'x', 'y'].includes(keyLower)) {
                            const value = item[key];
                            if (value !== null && value !== undefined && value !== '') {
                              popupContent += `<strong>${key}:</strong> ${value}<br>`;
                            }
                          }
                        });
                        popupContent += '</div>';

                        marker.bindPopup(popupContent);
                        this.layer.addLayer(marker);
                        count++;
                      } else {
                        console.warn(`Invalid coordinates: lat=${latNum}, lon=${lonNum}`);
                        skippedCount++;
                      }
                    } else {
                      // Debug: Show what fields are available
                      if (skippedCount === 0) { // Only log first item
                        console.log('Available fields in data:', Object.keys(item));
                        console.log('Sample item:', item);
                      }
                      skippedCount++;
                    }
                  });
                  
                  console.log(`‚úì Added ${count} markers from API (${skippedCount} items skipped)`);
                  
                  if (count === 0 && data.length > 0) {
                    console.warn('No markers added. Check coordinate field names.');
                    console.log('First item structure:', data[0]);
                  }
                }
              } catch (error) {
                console.error('API parse hatasƒ±:', error);
                throw new Error('API verisi i≈ülenemedi: ' + error.message);
              }
            }

            async processGeoJsonUrl(url) {
              console.log('üó∫Ô∏è Processing GeoJSON URL:', url);
              try {
                const response = await fetch(url);
                const geojson = await response.json();
                this.addGeoJSON(geojson);
              } catch (error) {
                console.error('GeoJSON URL parse hatasƒ±:', error);
                throw new Error('GeoJSON y√ºklenemedi');
              }
            }

            addGeoJSON(geojson) {
              console.log('üìç Adding GeoJSON to map...');

              if (!geojson || !geojson.features) {
                console.warn('Ge√ßersiz GeoJSON format');
                return;
              }

              // Create cluster group for points
              const cluster = L.markerClusterGroup({
                spiderfyOnEveryZoom: false,
                spiderfyOnMaxZoom: true,
                showCoverageOnHover: false,
                disableClusteringAtZoom: 16,
                maxClusterRadius: 50,
                chunkedLoading: true,
                chunkInterval: 50,
                chunkDelay: 5,
                animate: false
              });

              const pointFeatures = [];
              const nonPointFeatures = [];

              // Separate point and non-point features
              geojson.features.forEach(feature => {
                if (feature.geometry && feature.geometry.type === 'Point') {
                  pointFeatures.push(feature);
                } else {
                  nonPointFeatures.push(feature);
                }
              });

              // Add point features to cluster
              pointFeatures.forEach(feature => {
                const [lon, lat] = feature.geometry.coordinates;
                const marker = L.circleMarker([lat, lon], {
                  radius: 6,
                  fillColor: "#667eea",
                  color: "#fff",
                  weight: 2,
                  fillOpacity: 0.8
                });

                // Add popup
                if (feature.properties) {
                  let popupContent = '<div class="popup-content">';
                  Object.keys(feature.properties).forEach(key => {
                    if (feature.properties[key] !== null && feature.properties[key] !== undefined) {
                      popupContent += `<strong>${key}:</strong> ${feature.properties[key]}<br>`;
                    }
                  });
                  popupContent += '</div>';
                  marker.bindPopup(popupContent);
                }

                cluster.addLayer(marker);
              });

              // Add non-point features
              if (nonPointFeatures.length > 0) {
                const nonPointGeoJSON = {
                  type: 'FeatureCollection',
                  features: nonPointFeatures
                };

                const geoJsonLayer = L.geoJSON(nonPointGeoJSON, {
                  style: {
                    color: "#667eea",
                    weight: 2,
                    opacity: 0.8,
                    fillOpacity: 0.3
                  },
                  onEachFeature: (feature, layer) => {
                    if (feature.properties) {
                      let popupContent = '<div class="popup-content">';
                      Object.keys(feature.properties).forEach(key => {
                        if (feature.properties[key] !== null && feature.properties[key] !== undefined) {
                          popupContent += `<strong>${key}:</strong> ${feature.properties[key]}<br>`;
                        }
                      });
                      popupContent += '</div>';
                      layer.bindPopup(popupContent);
                    }
                  }
                });

                this.layer.addLayer(geoJsonLayer);
              }

              // Add cluster to layer if it has points
              if (cluster.getLayers().length > 0) {
                this.layer.addLayer(cluster);
              }

              console.log(`‚úì Added ${geojson.features.length} features (${pointFeatures.length} points, ${nonPointFeatures.length} non-points)`);
            }

            fitMapToBounds() {
              const layers = this.layer.getLayers();

              if (layers.length === 0) {
                console.log('No layers to fit');
                return;
              }

              try {
                // Try to get bounds from layer group
                const bounds = this.layer.getBounds();
                if (bounds && bounds.isValid()) {
                  this.map.fitBounds(bounds, { padding: [50, 50] });
                  console.log('‚úì Map fitted to bounds');
                  return;
                }
              } catch (e) {
                console.log('Manual bounds calculation needed');
              }

              // Manual bounds calculation
              let minLat = Infinity, maxLat = -Infinity;
              let minLng = Infinity, maxLng = -Infinity;
              let hasValidBounds = false;

              const processLayer = (layer) => {
                if (layer.getBounds) {
                  try {
                    const bounds = layer.getBounds();
                    minLat = Math.min(minLat, bounds.getSouth());
                    maxLat = Math.max(maxLat, bounds.getNorth());
                    minLng = Math.min(minLng, bounds.getWest());
                    maxLng = Math.max(maxLng, bounds.getEast());
                    hasValidBounds = true;
                  } catch (e) {}
                } else if (layer.getLatLng) {
                  const latlng = layer.getLatLng();
                  minLat = Math.min(minLat, latlng.lat);
                  maxLat = Math.max(maxLat, latlng.lat);
                  minLng = Math.min(minLng, latlng.lng);
                  maxLng = Math.max(maxLng, latlng.lng);
                  hasValidBounds = true;
                }
              };

              layers.forEach(layer => {
                if (layer.eachLayer) {
                  // Process nested layers (like clusters)
                  layer.eachLayer(processLayer);
                } else {
                  processLayer(layer);
                }
              });

              if (hasValidBounds) {
                const bounds = [[minLat, minLng], [maxLat, maxLng]];
                this.map.fitBounds(bounds, { padding: [50, 50] });
                console.log('‚úì Map fitted to calculated bounds');
              } else {
                console.log('Could not calculate bounds, using default view');
              }
            }

            showError(message) {
              const errorDiv = document.createElement('div');
              errorDiv.className = 'alert alert-danger';
              errorDiv.style.margin = '20px';
              errorDiv.innerHTML = `
                <strong>‚ö†Ô∏è Hata:</strong> ${message}<br>
                <small>Veriyi g√∂r√ºnt√ºlemek i√ßin <a href="/mekansal">Mekansal G√∂sterim</a> sayfasƒ±nƒ± deneyin.</small>
              `;
              const mapContainer = document.getElementById('leaflet-map');
              if (mapContainer && mapContainer.parentElement) {
                mapContainer.parentElement.insertBefore(errorDiv, mapContainer);
              }
            }
          }

          // Main initialization
          (function() {
            const resourceId = '{{ res.id }}';

            // Check if spatial
            fetch('/api/spatial-resources/list')
              .then(r => r.json())
              .then(data => {
                if (data.success && data.spatial_resources) {
                  const isSpatial = data.spatial_resources.some(r => r.resource_id === resourceId);

                  if (isSpatial) {
                    console.log('‚úì SPATIAL RESOURCE - Loading map...');

                    // Hide standard preview, show map
                    document.getElementById('standard-preview-container').style.display = 'none';
                    document.getElementById('spatial-map-container').style.display = 'block';

                    // Initialize map
                    setTimeout(() => {
                      window.spatialMap = L.map('leaflet-map').setView([38.4237, 27.1428], 10);
                      console.log('‚úì Map created');

                      // Load data with enhanced handler
                      const handler = new ResourceSpatialHandler(resourceId, window.spatialMap);
                      handler.loadData();
                    }, 100);

                  } else {
                    console.log('Standard resource - showing preview');
                  }
                }
              })
              .catch(e => console.error('Error checking spatial:', e));
          })();
        </script>

      {% endblock %}
      {% endblock %}
      {% endif %}
      {% endblock %}
    </section>
  {% endblock %}
{% endblock %}

{% block primary_content %}
  {% block resource_additional_information %}
    {% if res %}
      <section class="module">
        <div class="module-content">
          <h2>{{ _('Additional Information') }}</h2>
          <table class="table table-striped table-bordered table-condensed" data-module="table-toggle-more">
            <thead>
              <tr>
                <th scope="col">{{ _('Field') }}</th>
                <th scope="col">{{ _('Value') }}</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <th scope="row">{{ _('Format') }}</th>
                <td>{{ res.format or res.mimetype_inner or res.mimetype or _('unknown') }}</td>
              </tr>
              <tr>
                <th scope="row">{{ _('License') }}</th>
                <td>{% snippet "snippets/license.html", pkg_dict=pkg, text_only=True %}</td>
              </tr>
            </tbody>
          </table>
        </div>
      </section>
    {% endif %}
  {% endblock %}
{% endblock %}

{% block secondary_content %}
  {% block resources_list %}
    {% snippet "package/snippets/resources.html", pkg=pkg, active=res.id, action='read', is_activity_archive=is_activity_archive %}
  {% endblock %}
{% endblock %}